<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Multilegged Authentication for HTTP Multiplexing</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Overview"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Multilegged Authentication in HTTP/1.X"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Multilegged Authentication in the Presence of Multiplexing"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Request Management"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 The Auth-ID Header"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 The Persistent-Auth Response Header"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Stateful Authentication via Proxies"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 HTTP/1.1 Client Authenticating to HTTP/2 Server via HTTP/2 Proxy"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 HTTP/2 Client Authenticating to an HTTP/1.1 Server via HTTP/2 Proxy"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 HTTP/2 Client Authenticating to an HTTP/2 Server via HTTP/2 Proxy"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Authentication and multi-host sessions"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Interaction with Legacy Peers"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations"/>
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="9 References"/>
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Acknowledgements"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Montenegro, G. and M. Bishop" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-montenegro-httpauth-multilegged-auth-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-12-30" />
  <meta name="dct.abstract" content="HTTP/2 intends to be compatible with all widely deployed HTTP features, including currently-deployed authentication schemes. However, some currently-defined schemes don&#8217;t coexist well with multiplexing. This draft addresses some of the issues encountered when performing multilegged authentication over a multiplexed channel." />
  <meta name="description" content="HTTP/2 intends to be compatible with all widely deployed HTTP features, including currently-deployed authentication schemes. However, some currently-defined schemes don&#8217;t coexist well with multiplexing. This draft addresses some of the issues encountered when performing multilegged authentication over a multiplexed channel." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Hypertext Transfer Protocol Authentication</td>
  <td class="right">G. Montenegro</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">M. Bishop</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">Microsoft</td>
</tr>
<tr>
  <td class="left">Expires: July 3, 2017</td>
  <td class="right">December 30, 2016</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Multilegged Authentication for HTTP Multiplexing<br />
  <span class="filename">draft-montenegro-httpauth-multilegged-auth-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>HTTP/2 intends to be compatible with all widely deployed HTTP features, including currently-deployed authentication schemes. However, some currently-defined schemes don&#8217;t coexist well with multiplexing. This draft addresses some of the issues encountered when performing multilegged authentication over a multiplexed channel.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on July 3, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Overview</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a></li>
</ul><li>2.   <a href="#rfc.section.2">Multilegged Authentication in HTTP/1.X</a></li>
<li>3.   <a href="#rfc.section.3">Multilegged Authentication in the Presence of Multiplexing</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Request Management</a></li>
<li>3.2.   <a href="#rfc.section.3.2">The Auth-ID Header</a></li>
<li>3.3.   <a href="#rfc.section.3.3">The Persistent-Auth Response Header</a></li>
</ul><li>4.   <a href="#rfc.section.4">Stateful Authentication via Proxies</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">HTTP/1.1 Client Authenticating to HTTP/2 Server via HTTP/2 Proxy</a></li>
<li>4.2.   <a href="#rfc.section.4.2">HTTP/2 Client Authenticating to an HTTP/1.1 Server via HTTP/2 Proxy</a></li>
<li>4.3.   <a href="#rfc.section.4.3">HTTP/2 Client Authenticating to an HTTP/2 Server via HTTP/2 Proxy</a></li>
</ul><li>5.   <a href="#rfc.section.5">Authentication and multi-host sessions</a></li>
<li>6.   <a href="#rfc.section.6">Interaction with Legacy Peers</a></li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a></li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a></li>
<li>9.   <a href="#rfc.references">References</a></li>
<ul><li>9.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Acknowledgements</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#overview" id="overview">Overview</a></h1>
<p id="rfc.section.1.p.1">This document defines multilegged authentication for a multiplexed version of HTTP, such as HTTP/2 (<a href="#RFC7540">[RFC7540]</a>) or HTTP/QUIC (<a href="#I-D.ietf-quic-http">[I-D.ietf-quic-http]</a>).</p>
<p><a href="#RFC4178">[RFC4178]</a> defines the Simple and Protected GSS-API Negotiation Mechanism (SPNEGO), a GSS-API (<a href="#RFC2743">[RFC2743]</a>) pseudo-security method for negotiating which of several GSS-API credentials a client has might be acceptable to the server. Several GSS-API authentication types, including SPNEGO, can require multiple round-trips between client and server for authentication to complete.</p>
<p><a href="#RFC4559">[RFC4559]</a> describes how SPNEGO-based authentication methods can be used in HTTP.  HTTP contemplates such multi-legged authentication methods &#8211; <a href="#RFC7235">[RFC7235]</a> explicitly requires the use of status code 401 when a request contains &#8220;partial credentials (e.g., when the authentication scheme requires more than one round trip).&#8221; However, existing multi-legged authentication schemes such as SPNEGO assume that subsequent requests can be correlated because they occur in sequence on a single TCP connection. This correlation is not possible for multiplexed versions of HTTP.</p>
<p id="rfc.section.1.p.4">Current implementations address this by converting attempts to use these authentication schemes into HTTP_1_1_REQUIRED errors. However, this introduces multiple additional round trips into any scenario that requires authentication &#8211; the client will first establish an HTTP/2 connection, then encounter the fallback error code, establish an HTTP/1.1 connection, retry the request, and only then receive the authentication challenge to which they must respond.</p>
<p id="rfc.section.1.p.5">SCRAM (<a href="#RFC5802">[RFC5802]</a>), a more recent authentication method, is also multi-legged. However, SCRAM solves this problem itself by incorporating a nonce into the server&#8217;s challenge which the client MUST echo back to the server. This permits the server to know to which challenge the client is attempting to respond, if multiple were issued.</p>
<p id="rfc.section.1.p.6">The following table summarizes widely deployed authentication schemes, their authentication types, and the authentication level they provide:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left"/>
      <th class="center">Scheme</th>
      <th class="center">Type of Authentication</th>
      <th class="left">Authentication Level</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left"/>
      <td class="center">Basic</td>
      <td class="center">Per Request</td>
      <td class="left">Request</td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="center">Digest</td>
      <td class="center">Per Request</td>
      <td class="left">Request</td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="center">NTLM</td>
      <td class="center">Multilegged</td>
      <td class="left">Connection</td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="center">Kerberos</td>
      <td class="center">Multilegged</td>
      <td class="left">Connection or Request</td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="center">Negotiate</td>
      <td class="center">Multilegged</td>
      <td class="left">Connection or Request</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.1.p.7">To enable better support of multilegged authentication, we propose that the shared state for which some authentication schemes rely upon the TCP connection (thereby making messages stateful) be moved into the HTTP layer, as SCRAM has done.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#requirements-language" id="requirements-language">Requirements Language</a></h1>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#multilegged-authentication-in-http1x" id="multilegged-authentication-in-http1x">Multilegged Authentication in HTTP/1.X</a></h1>
<p id="rfc.section.2.p.1">As implied by its name, multilegged authentication requires multiple roundtrips to establish an authenticated communication channel between client and server. If the resource requested by a client requires authentication, the server initiates the authentication process as follows:</p>
<div id="rfc.figure.1"/>
<div id="figure-existing"/>
<pre>
  Client                                 Server
    |                                      |
    | -------- (0) HTTP GET Request ----&gt;  |
    |                                      |
    | &lt;------- (1) HTTP 401 -------------  |
    |              WWW-Authenticate header |
    |                                      |
    | -------- (2) HTTP GET Request ----&gt;  |
    |              Authorization header    |
    |                                      |
    | &lt;------- (3) HTTP 401 -------------  |
    |              WWW-Authenticate header |
    |                                      |
    | -------- (4) HTTP GET Request ----&gt;  |
    |              Authorization header    |
    |                                      |
    | &lt;------- (5) HTTP 200 OK-----------  |
    |              WWW-Authenticate header |
    |                                      |
    v                                      v
</pre>
<p class="figure">Figure 1: Multilegged authentication example</p>
<p/>

<ol>
  <li>Server sends HTTP 401 response because the resource requested requires authentication.  Response includes <samp>WWW-Authenticate</samp> header describing acceptable authentication method(s) and possibly challenge information.</li>
  <li>Client re-issues the HTTP GET request for the resource, including an Authorization header.</li>
  <li>Server optionally responds with an HTTP 401 and <samp>WWW-Authenticate</samp> header if the client&#8217;s credentials were incomplete.</li>
  <li>If needed, client re-issues the HTTP GET Request for the resource, including an <samp>Authorization</samp> header with the additional information required to complete authentication.</li>
  <li>If authentication succeeds, the server responds with an HTTP 200 status code and including the requested resource.</li>
</ol>
<p id="rfc.section.2.p.3">On a multiplexed protocol, the request/response pairs 0/1, 2/3, and 4/5 will occur on different streams, with other requests occurring in parallel.  When the server sees request #4, it cannot correlate that Authorization header with the <samp>WWW-Authenticate</samp> header on response #3 (as compared to other <samp>WWW-Authenticate</samp> headers that may have been sent on the same connection).</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#multilegged-authentication-in-the-presence-of-multiplexing" id="multilegged-authentication-in-the-presence-of-multiplexing">Multilegged Authentication in the Presence of Multiplexing</a></h1>
<p id="rfc.section.3.p.1">In a multiplexing protocol such as HTTP/2, multiple client requests can be outstanding at one time. In the event that multiple requests receive authentication challenges, the server cannot reliably determine to which challenge the client is responding in subsequent authentication attempts. Current implementations force a fallback to HTTP/1.1 to work around this limitation.</p>
<p><a href="#figure-proposed">Figure 2</a> below provides a breakdown of proposed network flows to implement multilegged authentication for multiplexing:</p>
<div id="rfc.figure.2"/>
<div id="figure-proposed"/>
<pre>
                                       Multiplexing
   Client                               HTTP Server
      |                                      |
      | -------- (0) HTTP GET Request ----&gt;  |
      |                                      |
      | &lt;------- (1) HTTP 401 -------------  |
      |              WWW-Authenticate header |
      |              (Auth-ID header)        |
      |                                      |
      | -------- (2) HTTP Get Request ----&gt;  |
      |              Authorization header    |
      |              (Auth-ID header)        |
      |                                      |
      | &lt;------- (3) HTTP 401 -------------  |
      |              WWW-Authenticate header |
      |              Auth-ID header          |
      |                                      |
      | -------- (4) HTTP Get Request ----&gt;  |
      |              Authorization header    |
      |              Auth-ID header          |
      |                                      |
      | &lt;------- (5) HTTP 200 OK-----------  |
      |              WWW-Authenticate header |
      |              (Persistent-Auth header)|
      |                                      |
      |                                      |
      v                                      v
</pre>
<p class="figure">Figure 2: Proposed multilegged authentication</p>
<p/>

<ol>
  <li>Server sends HTTP 401 response because the resource requested requires authentication.  If the <samp>WWW-Authenticate</samp> header contains any state, the server MUST include an <samp>Auth-ID</samp> header. (See <a href="#header-auth-id">Section 3.2</a>).</li>
  <li>Client re-issues the HTTP GET request for the resource, including the <samp>Authorization</samp> header.  If the server provided an <samp>Auth-ID</samp> header, the client MUST echo the same value on the subsequent request.</li>
  <li>If additional information is required, server responds with an HTTP 401 and a <samp>WWW-Authenticate</samp> header requesting additional information.  An <samp>Auth-ID</samp> header MUST be included, since the additional information relies on existing state already provided by the client.</li>
  <li>Client re-issues the HTTP GET request for the resource and MUST include the required <samp>Authorization</samp> header and the <samp>Auth-ID</samp> header, to inform the server that the request is part of a previously-initiated multilegged authentication process.</li>
  <li>Authentication succeeds and the server returns the requested resource.  If the exchange authenticated the connection, the server SHOULD include a <samp>Persistent-Auth</samp> header (see <a href="#header-Persistent-auth">Section 3.3</a>).</li>
</ol>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#request-management" id="request-management">Request Management</a></h1>
<p id="rfc.section.3.1.p.1">Multilegged authentication schemes could authenticate individual requests or the HTTP/2 session. Clients SHOULD NOT attempt to authenticate individual requests when the HTTP connection has already been authenticated.</p>
<p id="rfc.section.3.1.p.2">The client MUST NOT send multiple requests in parallel with the same Auth-ID, and SHOULD NOT send multiple requests in parallel with different Auth-IDs if any of those requests is expected to result in connection-level authentication. If an HTTP/2 session has a stream in process of authenticating using a multilegged authentication scheme and the client does not know whether the request will authenticate the connection, the client SHOULD queue all subsequent requests which require authentication on the session until the multilegged authentication completes. If the client does not queue the requests, then it might unnecessarily authenticate streams in a session that has already been authenticated. However, if a server receives multiple authenticated requests from the same client, it SHOULD NOT block responses.</p>
<p id="rfc.section.3.1.p.3">If connection-based multilegged authentication succeeds a second time on a previously authenticated session, the server SHOULD discard the previous authentication context and authenticate the session with the newly negotiated authentication context.</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#header-auth-id" id="header-auth-id">The Auth-ID Header</a></h1>
<p id="rfc.section.3.2.p.1">If the server responds to a request with a &#8220;401 Unauthorized&#8221; status code and the <samp>WWW-Authenticate</samp> header (required by <a href="#RFC7235">[RFC7235]</a>) contains state in its <samp>auth-data</samp> value, the server MUST also include an Auth-ID header. If the request to which the server is responding contained an Auth-ID header, it MUST include an <samp>Auth-ID</samp> header in its response, and the value in the server&#8217;s response SHOULD be the same.</p>
<p id="rfc.section.3.2.p.2">A server MAY generate and add an <samp>Auth-ID</samp> header as soon as it knows that the requested authentication scheme is multilegged.  The client MUST add the <samp>Auth-ID</samp> header to all subsequent requests required to complete the authentication process.</p>
<p id="rfc.section.3.2.p.3">When a client sends a request with an Authorization header after receiving a &#8220;401 Unauthorized&#8221; status code bearing an <samp>Auth-ID</samp> header, it MUST include an identical <samp>Auth-ID</samp> header in the request if the client&#8217;s Authorization header relies on any state from the server&#8217;s WWW-Authenticate header, or if the <samp>WWW-Authenticate</samp> header was sent in response to a request bearing an <samp>Auth-ID</samp> header.</p>
<p id="rfc.section.3.2.p.4">The <samp>Auth-ID</samp> header is defined as follows:</p>
<pre>
Auth-ID = token; see [RFC7230], Section 3.2.6
</pre>
<p id="rfc.section.3.2.p.5">The <samp>Auth-ID</samp> header represents a key into short-lived data on the server associated with the current connection, and MAY be selected by the server using any implementation-defined method. It is an opaque identifier, and clients MUST NOT attempt to interpet it. The Auth-ID mapping is destroyed when the authentication process completes, whether in success or failure.</p>
<p id="rfc.section.3.2.p.6">Servers SHOULD limit the number of incomplete security contexts per session, to protect against misbehaving clients that cause the server to create multiple authentication contexts but never complete the authentication process. Servers SHOULD define a maximum number of incomplete security contexts and discard inactive contexts.  If a request contains an unknown or expired Auth-ID, the request should be treated as containing no Auth-ID.</p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#header-Persistent-auth" id="header-Persistent-auth">The Persistent-Auth Response Header</a></h1>
<p id="rfc.section.3.3.p.1">Some multilegged authentication schemes can result in per-request or per-connection (i.e., Kerberos or Negotiate) authentication. When a session is authenticated, servers SHOULD generate a <samp>Persistent-Auth</samp> header and send it along with the HTTP 200 OK response.</p>
<p id="rfc.section.3.3.p.2">The <samp>Persistent-Auth</samp> header is defined as follows:</p>
<pre>
Persistent-Auth = "true" / "false"
</pre>
<p id="rfc.section.3.3.p.3">A <samp>Persistent-Auth</samp> header with an unknown value, or the absence of a <samp>Persistent-Auth</samp> header, MUST be treated as the value &#8220;false&#8221;. The client MUST use the <samp>Persistent-Auth</samp> header to determine what action to take with queued or subsequent requests:</p>
<p/>

<ol>
  <li>If the session was authenticated, as indicated by the presence of the <samp>Persistent-Auth</samp> header with the value &#8220;true&#8221;, the client does not need to authenticate new streams it creates to service future requests on the authenticated session.</li>
  <li>If the session was not authenticated, as indicated by the absence of the <samp>Persistent-Auth</samp> header or the value &#8220;false&#8221;, the client SHOULD remember the negotiated authentication scheme used for authentication.  The client SHOULD NOT block streams on the session when processing requests using the multilegged authentication scheme that previously resulted in per-request authentication.</li>
</ol>
<p id="rfc.section.3.3.p.5">Clients SHOULD assume that successful authentication with schemes that only support connection-based authentication (e.g. NTLM) always results in an authenticated session, even if the <samp>Persistent-Auth</samp> header is not present.</p>
<p id="rfc.section.3.3.p.6">The client CANNOT make any assumptions by the absence of the <samp>Persistent-Auth</samp> header until the authentication process is complete and it receives the final server response containing the requested resource.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#stateful-authentication-via-proxies" id="stateful-authentication-via-proxies">Stateful Authentication via Proxies</a></h1>
<p id="rfc.section.4.p.1">Typically, authenticated connections via a forward proxy will occur using the CONNECT method (<a href="#RFC7231">[RFC7231]</a>, Section 4.3.6) and the proxy will not be involved in the authentication flow. Authenticated connections via a reverse proxy will often terminate authentication at the proxy, with only authorized requests reaching the content server.</p>
<p id="rfc.section.4.p.2">When the proxy speaks only HTTP/1.1, no multiplexing will occur and the considerations in this document do not apply. Proxy and gateway applications should take the consideration outlined by <a href="#RFC7230">[RFC7230]</a> when forwarding messages between client and servers with different protocol version capabilities.</p>
<p id="rfc.section.4.p.3">This section applies only to situations where the proxy has access to the requests but is not performing authentication itself, and is using HTTP/2 to communicate with the client, the server, or both.</p>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#http11-client-authenticating-to-http2-server-via-http2-proxy" id="http11-client-authenticating-to-http2-server-via-http2-proxy">HTTP/1.1 Client Authenticating to HTTP/2 Server via HTTP/2 Proxy</a></h1>
<p id="rfc.section.4.1.p.1">When the proxy uses HTTP/2 to connect to the server, it MUST ensure that any authentication method that could result in per-connection authentication is used only on a separate connection for each client.  This could require replaying requests on a new connection.</p>
<p id="rfc.section.4.1.p.2">For per-request authentication methods, the server MUST associate each received <samp>Auth-ID</samp> from the server to the client TCP connection and insert the <samp>Auth-ID</samp> header on future requests originating from the same connection which contain an <samp>Authorization</samp> header.</p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#http2-client-authenticating-to-an-http11-server-via-http2-proxy" id="http2-client-authenticating-to-an-http11-server-via-http2-proxy">HTTP/2 Client Authenticating to an HTTP/1.1 Server via HTTP/2 Proxy</a></h1>
<p id="rfc.section.4.2.p.1">HTTP/2 clients can multiplex streams within the authenticated HTTP/2 client-proxy session, but the proxy MUST serialize these requests through HTTP/1.1 proxy-server connections. These connections MUST NOT be shared between different clients if per-connection authorization is in use, and SHOULD NOT be shared between different clients even if per-request authorization is in use.</p>
<p id="rfc.section.4.2.p.2">The proxy MUST generate and insert an <samp>Auth-ID</samp> header corresponding to each TCP connection it maintains to the server, and add the <samp>Auth-ID</samp> header to any 401 response from the server. Client requests which include an <samp>Auth-ID</samp> header MUST be directed to the associated TCP connection, or a new connection if that one has closed. Requests which do not include an <samp>Auth-ID</samp> header MAY be relayed over any connection.</p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#http2-client-authenticating-to-an-http2-server-via-http2-proxy" id="http2-client-authenticating-to-an-http2-server-via-http2-proxy">HTTP/2 Client Authenticating to an HTTP/2 Server via HTTP/2 Proxy</a></h1>
<p id="rfc.section.4.3.p.1">The proxy MUST bind the HTTP/2 connections it maintains with the client and server, using a separate connection to the server for each client.  The proxy MUST relay the <samp>Auth-ID</samp> and <samp>Persistent-Auth</samp> headers unmodified between these connections.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#authentication-and-multi-host-sessions" id="authentication-and-multi-host-sessions">Authentication and multi-host sessions</a></h1>
<p id="rfc.section.5.p.1">Clients MUST NOT make requests to multiple origins when per-connection authentication has been established to one origin.  If an authentication scheme which might result in per-connection authentication is requested on a connection which has already been used to make requests of multiple origins, the client SHOULD repeat the request on a different connection.</p>
<p id="rfc.section.5.p.2">Servers SHOULD respond to requests for different origins on an authenticated connection with the 421 status code (defined in <a href="#RFC7540">[RFC7540]</a>), requiring clients to retry on a separate connection.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#interaction-with-legacy-peers" id="interaction-with-legacy-peers">Interaction with Legacy Peers</a></h1>
<p id="rfc.section.6.p.1">Servers and clients which do not implement this specification are expected to treat attempts at multi-legged authentication as situations which require a fallback to HTTP/1.1.  Clients which implement this specification and encounter</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.7.p.1">Implementers should be aware of the security considerations defined by the individual authentication schemes supported. The following are some general security considerations that are independent of the proposed authentication mechanism.</p>
<p id="rfc.section.7.p.2">The proposed authentication mechanism is only used to provide authentication of a user to a server. It provides no facilities for protecting the HTTP headers or data including the Authorization and WWW-Authenticate headers that are used to implement this mechanism.</p>
<p id="rfc.section.7.p.3">Alternate mechanisms such as TLS can be used to provide confidentiality.  Hashes of the TLS certificates can be used as channel bindings to secure the channel. In this case, clients would need to enforce that the channel binding information is valid.</p>
<p id="rfc.section.7.p.4">If an HTTP proxy is used between the client and server, it MUST take care to not share authenticated connections between different authenticated clients to the same server. If this is not honored, then the server can easily lose track of security context associations.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.8.p.1">HTTP header fields are registered within the &#8220;Message Headers&#8221; registry maintained at <a href="http://www.iana.org/assignments/message-headers/">http://www.iana.org/assignments/message-headers/</a>.</p>
<p id="rfc.section.8.p.2">This document defines the following HTTP header fields in the &#8220;Provisional Message Header Field Names&#8221; registry (see <a href="#RFC3864">[RFC3864]</a>).</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left"/>
      <th class="left">Header Field Name</th>
      <th class="left">Protocol</th>
      <th class="left">Status</th>
      <th class="left">Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left"/>
      <td class="left">Auth-ID</td>
      <td class="left">http</td>
      <td class="left">provisional</td>
      <td class="left">
        <a href="#header-auth-id">Section 3.2</a>
      </td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">Persistent-Auth</td>
      <td class="left">http</td>
      <td class="left">provisional</td>
      <td class="left">
        <a href="#header-Persistent-auth">Section 3.3</a>
      </td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.8.p.3">The change controllers are the authors of this document.</p>
<h1 id="rfc.references"><a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">9.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7230">[RFC7230]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7235">[RFC7235]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7235">Hypertext Transfer Protocol (HTTP/1.1): Authentication</a>", RFC 7235, DOI 10.17487/RFC7235, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7540">[RFC7540]</b>
      </td>
      <td class="top"><a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">9.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-quic-http">[I-D.ietf-quic-http]</b>
      </td>
      <td class="top"><a>Bishop, M.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-quic-http-00">Hypertext Transfer Protocol (HTTP) over QUIC</a>", Internet-Draft draft-ietf-quic-http-00, November 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2743">[RFC2743]</b>
      </td>
      <td class="top"><a>Linn, J.</a>, "<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>", RFC 2743, DOI 10.17487/RFC2743, January 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3864">[RFC3864]</b>
      </td>
      <td class="top"><a>Klyne, G.</a>, <a>Nottingham, M.</a> and <a>J. Mogul</a>, "<a href="http://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>", BCP 90, RFC 3864, DOI 10.17487/RFC3864, September 2004.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4178">[RFC4178]</b>
      </td>
      <td class="top"><a>Zhu, L.</a>, <a>Leach, P.</a>, <a>Jaganathan, K.</a> and <a>W. Ingersoll</a>, "<a href="http://tools.ietf.org/html/rfc4178">The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism</a>", RFC 4178, DOI 10.17487/RFC4178, October 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4559">[RFC4559]</b>
      </td>
      <td class="top"><a>Jaganathan, K.</a>, <a>Zhu, L.</a> and <a>J. Brezak</a>, "<a href="http://tools.ietf.org/html/rfc4559">SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows</a>", RFC 4559, DOI 10.17487/RFC4559, June 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5802">[RFC5802]</b>
      </td>
      <td class="top"><a>Newman, C.</a>, <a>Menon-Sen, A.</a>, <a>Melnikov, A.</a> and <a>N. Williams</a>, "<a href="http://tools.ietf.org/html/rfc5802">Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mechanisms</a>", RFC 5802, DOI 10.17487/RFC5802, July 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7231">[RFC7231]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a></h1>
<p id="rfc.section.A.p.1">The authors of the original version of this draft were Jonathan Silvera, Matthew Cox, Ivan Pashov, Osama Mazahir, and Gabriel Montenegro.</p>
<p id="rfc.section.A.p.2">Thanks to the following individuals who provided helpful feedback and contributed to discussions on this document: Paul Leach, Nathan Ide and Rob Trace.</p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Gabriel Montenegro</span> 
	  <span class="n hidden">
		<span class="family-name">Montenegro</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:Gabriel.Montenegro@microsoft.com">Gabriel.Montenegro@microsoft.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> 
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:Michael.Bishop@microsoft.com">Michael.Bishop@microsoft.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/MikeBishop/http-misc-extensions">Fork me on GitHub</a></div></div>
</body>
</html>
