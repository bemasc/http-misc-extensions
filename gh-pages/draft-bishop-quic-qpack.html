<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>QPACK - Header Compression for HTTP over QUIC</title>

  <style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Terminology"/>
<link href="#rfc.section.2" rel="Chapter" title="2 QPACK"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Changes to Static and Dynamic Tables"/>
<link href="#rfc.section.2.1.1" rel="Chapter" title="2.1.1 Dynamic table management and phase"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Changes to Binary Format"/>
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Literal Header Field Representation"/>
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Dynamic Table Phase Change"/>
<link href="#rfc.section.3" rel="Chapter" title="3 HTTP over QUIC Mapping Changes"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 On-Stream Framing Definition"/>
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 DATA"/>
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 HEADERS"/>
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 PUSH_PROMISE"/>
<link href="#rfc.section.3.1.4" rel="Chapter" title="3.1.4 Other frames not mentioned"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 HTTP Message Exchanges"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Performance Considerations"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="8 References"/>
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Bishop, M." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-bishop-quic-qpack-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-11-8" />
  <meta name="dct.abstract" content="HTTP/2 " />
  <meta name="description" content="HTTP/2 " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">QUIC Working Group</td>
  <td class="right">M. Bishop</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Microsoft</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">November 8, 2016</td>
</tr>
<tr>
  <td class="left">Expires: May 12, 2017</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">QPACK - Header Compression for HTTP over QUIC<br />
  <span class="filename">draft-bishop-quic-qpack-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>HTTP/2 <a href="#RFC7540">[RFC7540]</a> uses HPACK <a href="#RFC7541">[RFC7541]</a> for header compression.  However, HPACK relies on the in-order message-based semantics of the HTTP/2 framing layer in order to function.  Messages can only be successfully decoded if processed by the receiver in the same order as generated by the sender.  This draft refines HPACK to loosen the ordering requirements for use over QUIC <a href="#I-D.hamilton-quic-transport-protocol">[I-D.hamilton-quic-transport-protocol]</a>.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 12, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Terminology</a></li>
</ul><li>2.   <a href="#rfc.section.2">QPACK</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Changes to Static and Dynamic Tables</a></li>
<ul><li>2.1.1.   <a href="#rfc.section.2.1.1">Dynamic table management and phase</a></li>
</ul><li>2.2.   <a href="#rfc.section.2.2">Changes to Binary Format</a></li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Literal Header Field Representation</a></li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Dynamic Table Phase Change</a></li>
</ul></ul><li>3.   <a href="#rfc.section.3">HTTP over QUIC Mapping Changes</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">On-Stream Framing Definition</a></li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">DATA</a></li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">HEADERS</a></li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">PUSH_PROMISE</a></li>
<li>3.1.4.   <a href="#rfc.section.3.1.4">Other frames not mentioned</a></li>
</ul><li>3.2.   <a href="#rfc.section.3.2">HTTP Message Exchanges</a></li>
</ul><li>4.   <a href="#rfc.section.4">Performance Considerations</a></li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a></li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a></li>
<li>8.   <a href="#rfc.references">References</a></li>
<ul><li>8.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Author's Address</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#problems" id="problems">Introduction</a></h1>
<p id="rfc.section.1.p.1">HPACK has a number of features that were intended to provide performance advantages to HTTP/2, but which don&#8217;t live well in an out-of-order environment such as that provided by QUIC.</p>
<p id="rfc.section.1.p.2">The largest challenge is the fact that elements are referenced by a very fluid index. Not only is the index implicit when an item is added to the header table, the index will change without notice as other items are added to the header table. Static entries occupy the first 61 values, followed by dynamic entries. A newly-added dynamic entry would cause older dynamic entries to be evicted, and the retained items are then renumbered beginning with 62. This means that, without processing all preceding header sets, no index into the dynamic table can be interpreted, and the index of a given entry cannot be predicted.</p>
<p id="rfc.section.1.p.3">Any solution to the above will almost certainly fall afoul of the memory constraints the decompressor imposes. The automatic eviction of entries is done based on the compressor&#8217;s declared dynamic table size, which MUST be less than the maximum permitted by the decompressor (and relayed using an HTTP/2 SETTINGS value).</p>
<p id="rfc.section.1.p.4">In the following sections, this document proposes a new version of HPACK which makes different trade-offs, enabling out-of-order interpretation and bounded memory consumption with minimal head-of-line blocking.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#Terminology" id="Terminology">Terminology</a></h1>
<p id="rfc.section.1.1.p.1">In this document, the key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; are to be interpreted as described in BCP 14, RFC 2119 <a href="#RFC2119">[RFC2119]</a> and indicate requirement levels for compliant STuPiD implementations.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#QPACK" id="QPACK">QPACK</a></h1>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#changes-to-static-and-dynamic-tables" id="changes-to-static-and-dynamic-tables">Changes to Static and Dynamic Tables</a></h1>
<p id="rfc.section.2.1.p.1">QPACK uses two tables for associating header fields to indexes. The static table is unchanged from <a href="#RFC7541">[RFC7541]</a>.</p>
<p id="rfc.section.2.1.p.2">The dynamic table is a map from index to header field. Indices are arbitrary numbers greater than the last index of the static table. Each insert instruction will specify the index being modified. While any index MAY be chosen for a new entry, smaller numbers will yield better compression performance. Once an index has been assigned, its value is immutable for the lifetime of that dynamic table.</p>
<p id="rfc.section.2.1.p.3">(Note: Changing or deleting values re-introduces strong ordering requirements this draft attempts to eliminate. Suggestions for adding this feature without such requirements are welcome.)</p>
<p id="rfc.section.2.1.p.4">The dynamic table is still constrained to the size specified by the receiver. An attempt to add a header to the dynamic table which causes it to exceed the maximum size MUST be treated as an error by a decoder.</p>
<p id="rfc.section.2.1.p.5">Because it is possible for QPACK frames to arrive which reference indices which have not yet been defined, such frames MUST wait until another frame has arrived and defined the index. In order to guard against malicious senders, implementations SHOULD impose a time limit and treat expiration of the timer as a decoding error. However, if the implementation chooses not to abort the connection, the remainder of the header block MUST be decoded and the output discarded.</p>
<h1 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1.</a> <a href="#dynamic-table-management-and-phase" id="dynamic-table-management-and-phase">Dynamic table management and phase</a></h1>
<p id="rfc.section.2.1.1.p.1">No entries are evicted from the dynamic table. Size management is achieved using successive phases of dynamic table which evolve from each other.</p>
<p id="rfc.section.2.1.1.p.2">Each QPACK frame will contain two bits of phase, the sending phase and the received phase. When the dynamic table is approaching the maximum size, the encoder condenses the entries by sending a PHASE_CHANGE command (see <a href="#phase-change">Section 2.2.2</a>). The phase change creates a new dynamic table containing a subset of entries from the previous phase&#8217;s dynamic table. The encoder then discards the previous phase&#8217;s dynamic table and uses the new table as the basis for the remainder of the current frame and all future QPACK frames.</p>
<p id="rfc.section.2.1.1.p.3">The decoder will be unable to process any index references from the new phase until it has received the QPACK frame containing the phase-change instruction.</p>
<p id="rfc.section.2.1.1.p.4">When the decoder has received and processed all QPACK frames generated using the previous phase, it discards the previous phase&#8217;s dynamic table and changes the value of its received phase bit. An encoder MUST NOT generate a new PHASE_CHANGE command until it has received a QPACK frame with a received phase matching the updated sending phase value.</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#changes-to-binary-format" id="changes-to-binary-format">Changes to Binary Format</a></h1>
<h1 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#literal-header-field-representation" id="literal-header-field-representation">Literal Header Field Representation</a></h1>
<p id="rfc.section.2.2.1.p.1">(This section replaces <a href="#RFC7541">[RFC7541]</a>, Section 6.2.1.)</p>
<p id="rfc.section.2.2.1.p.2">A literal header field with indexing representation results in inserting a header field to the decoded header list and inserting it as a new entry into the dynamic table.</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 |    New Index (6+)     |
   +---+---+-----------------------+
   |          Name Index (8+)      |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
</pre>
<p class="figure">Literal Header Field with Indexing -- Indexed Name</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 |    New Index (6+)     |
   +---+---+-----------------------+
   |               0               |
   +---+---+-----------------------+
   | H |     Name Length (7+)      |
   +---+---------------------------+
   |  Name String (Length octets)  |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
</pre>
<p class="figure">Literal Header Field with Indexing -- New Name</p>
<p id="rfc.section.2.2.1.p.3">A literal header field with incremental indexing representation starts with the &#8216;01&#8217; 2-bit pattern, followed by the new index of the header represented as an integer with a 6-bit prefix. This value is always greater than the number of entries in the static table.</p>
<p id="rfc.section.2.2.1.p.4">If the header field name matches the header field name of an entry stored in the static table or the dynamic table, the header field name can be represented using the index of that entry. In this case, the index of the entry is represented as an integer with an 8-bit prefix (see Section 5.1). This value is always non-zero.</p>
<p id="rfc.section.2.2.1.p.5">Otherwise, the header field name is represented as a string literal (see Section 5.2). A value 0 is used in place of the 8-bit index, followed by the header field name.</p>
<p id="rfc.section.2.2.1.p.6">Either form of header field name representation is followed by the header field value represented as a string literal (see Section 5.2).</p>
<h1 id="rfc.section.2.2.2"><a href="#rfc.section.2.2.2">2.2.2.</a> <a href="#phase-change" id="phase-change">Dynamic Table Phase Change</a></h1>
<p id="rfc.section.2.2.2.p.1">(This section replaces <a href="#RFC7541">[RFC7541]</a>, Section 6.3.)</p>
<p id="rfc.section.2.2.2.p.2">A &#8220;Phase Change&#8221; instruction creates a new dynamic table consisting of entries from the previous phase&#8217;s dynamic table.  The new dynamic table begins empty, and the insertion index is placed at the first index after the static table.  The instructions are then processed in order to populate the new dynamic table.</p>
<p id="rfc.section.2.2.2.p.3">The Phase Change instruction begins with the count of QPACK frames which have already been encoded using the previous phase, followed by a sequence of instructions for generating the new dynamic table as follows:</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 | 1 |  Phase Count (5+) |
   +---+---------------------------+
   | Instructions...               |
   +---+---------------------------+   
</pre>
<p class="figure">Phase Change</p>
<p id="rfc.section.2.2.2.p.4">The count of preceding frames, given as a 5-bit prefix integer, does not include the frame containing the current Phase Change instruction or the frame containing the previous Phase Change instruction.</p>
<h1 id="rfc.section.2.2.2.1"><a href="#rfc.section.2.2.2.1">2.2.2.1.</a> <a href="#insert-single-entry-from-previous-phase" id="insert-single-entry-from-previous-phase">Insert single entry from previous phase</a></h1>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 |        Index (7+)         |
   +---+---------------------------+
</pre>
<p class="figure">Single Entry Insertion</p>
<p id="rfc.section.2.2.2.1.p.1">The entry with the specified entry from the previous phase&#8217;s dynamic table is inserted into the new phase&#8217;s dynamic table at the current insertion point and the insertion index is incremented.</p>
<h1 id="rfc.section.2.2.2.2"><a href="#rfc.section.2.2.2.2">2.2.2.2.</a> <a href="#insert-multiple-entries-from-previous-phase" id="insert-multiple-entries-from-previous-phase">Insert multiple entries from previous phase</a></h1>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 |      Count (6+)       |
   +---+---------------------------+
   |        Starting Index (8+)    |
   +---+---------------------------+
</pre>
<p class="figure">Multiple Entry Insertion</p>
<p id="rfc.section.2.2.2.2.p.1">A number of contiguous entries, given by Count, are read from the previous phase&#8217;s dynamic table and included at the insertion point in the new phase&#8217;s dynamic table, beginning at Starting Index.</p>
<h1 id="rfc.section.2.2.2.3"><a href="#rfc.section.2.2.2.3">2.2.2.3.</a> <a href="#complete-phase-change" id="complete-phase-change">Complete phase change</a></h1>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |               0               |
   +---+---+---+---+---+---+---+---+
</pre>
<p class="figure">End of Phase Change</p>
<p id="rfc.section.2.2.2.3.p.1">The encoder has discarded the previous dynamic table state and will use the newly-expressed state of the dynamic table for the remainder of this QPACK frame and for all future QPACK frames. The decoder should likewise discard the previous dynamic table once it has processed the specified number of frames using the previous phase.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#http-over-quic-mapping-changes" id="http-over-quic-mapping-changes">HTTP over QUIC Mapping Changes</a></h1>
<p><a href="#I-D.shade-quic-http2-mapping">[I-D.shade-quic-http2-mapping]</a> refers to QUIC Stream 3 as carrying &#8220;headers,&#8221; but more accurately, it carries a nearly-complete HTTP/2 session, complete with framing and multiplexing.  The mapping deletes certain elements of HTTP/2&#8217;s framing layer which can be delegated to the QUIC transport layer.</p>
<p id="rfc.section.3.p.2">This was done in large part for expediency, reusing HTTP/2 code in place anywhere no QUIC-specific approach had yet been added.  A primary driver of this is the need for in-order reliable delivery of frames carrying HPACK data (HEADERS, CONTINUATION, PUSH_PROMISE).</p>
<p id="rfc.section.3.p.3">QPACK would permit header data to be on-stream with the request/response bodies, but some framing is still required.  It would be possible (and perhaps desirable) to introduce a simplified version of HTTP/2&#8217;s framing on each QUIC stream.</p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#on-stream-framing-definition" id="on-stream-framing-definition">On-Stream Framing Definition</a></h1>
<p id="rfc.section.3.1.p.1">Many framing concepts from HTTP/2 can be elided away on QUIC, because the transport deals with them.  Because these frames would already be on a stream, they can omit the stream number.  Because the frames do not block multiplexing (QUIC&#8217;s multiplexing occurs below this layer), they can be as long as needed.  Because stream termination is handled by QUIC, END_STREAM is not required.</p>
<p id="rfc.section.3.1.p.2">We would also prefer to minimize the overhead of common frame types, since this is yet another layer of framing to be processed, so the frame type space has been reduced. If more frame types are needed, a type can be used to define a frame which contains a longer type field. (We could conceivably reduce the type to two bits and define that sub-type up front.)</p>
<p id="rfc.section.3.1.p.3">On QUIC streams other than Stream 1, the format is as follows:</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |          Length (16)          |
   |                               |
   +---+---+---+---+---+---+---+---+
   |    Type (4)   |     Flag(4)   |
   +---+---+---+---+---+---+---+---+
   |        Frame Payload        ...
   +---+---+---+---+---+---+---+---+
</pre>
<p class="figure">HTTP/QUIC frame format</p>
<p id="rfc.section.3.1.p.4">The frames currently defined are described in this section:</p>
<h1 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#data" id="data">DATA</a></h1>
<p id="rfc.section.3.1.1.p.1">DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets which make up the HTTP request or response payloads. No padding is defined, as QUIC provides facilities for this. No flags are defined.</p>
<h1 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#headers" id="headers">HEADERS</a></h1>
<p id="rfc.section.3.1.2.p.1">The HEADERS frame (type=0x1) is used to carry part of a header set, compressed using QPACK ({QPACK}).</p>
<p id="rfc.section.3.1.2.p.2">No padding is defined.  The flags defined are:</p>
<p/>

<ul>
  <li>Sending phase (0x1): The QPACK phase in use by the sender&#8217;s encoder when it began generating this frame.</li>
  <li>Receiving phase (0x2): The oldest QPACK phase still in use by the sender&#8217;s decoder when it began generating this frame.</li>
  <li>End Header Block (0x4): This frame concludes a header block.</li>
</ul>
<p id="rfc.section.3.1.2.p.4">The next frame after a HEADERS frame without the EHB flag set MUST be another HEADERS frame. A receiver MUST treat the receipt of any other type of frame as a connection error. (Note that QUIC may intersperse data from other streams between frames, or even during transmission of frames, so multiplexing is not blocked.)</p>
<p id="rfc.section.3.1.2.p.5">A full header block is contained in a sequence of zero or more HEADERS frames without EHB set, followed by a HEADERS frame with EHB set.</p>
<p id="rfc.section.3.1.2.p.6">HEADERS frames from various streams may be processed by the QPACK decoder in any order, completely or partially. It is not necessary to withhold decoding results until the end of the header block has arrived.  However, depending on the contents, the processing of a frame might not complete until other QPACK frames have arrived. The results of decoding MUST be emitted in the same order as the HEADERS frames were placed on the stream.</p>
<h1 id="rfc.section.3.1.3"><a href="#rfc.section.3.1.3">3.1.3.</a> <a href="#pushpromise" id="pushpromise">PUSH_PROMISE</a></h1>
<p id="rfc.section.3.1.3.p.1">The PUSH_PROMISE frame (type=0x02) is used to carry a request header set from server to client, as in HTTP/2. It contains the same flags as HEADERS, plus:</p>
<p/>

<ul>
  <li>Promised Stream Size (0x08): Indicates whether Promised Stream ID is 16 or 32-bits long.</li>
</ul>
<p id="rfc.section.3.1.3.p.3">The payload contains a QPACK headers block encoding the request whose response is promised, preceded by a 16-bit or 32-bit long Stream ID indicating the QUIC stream on which the response headers and body will be sent.</p>
<h1 id="rfc.section.3.1.4"><a href="#rfc.section.3.1.4">3.1.4.</a> <a href="#other-frames-not-mentioned" id="other-frames-not-mentioned">Other frames not mentioned</a></h1>
<p id="rfc.section.3.1.4.p.1">Still need a way to express connection-level ideas like PRIORITY and SETTINGS. PRIORITY really is talking <em>about</em> a stream, not data on it.  Perhaps these remain on Stream 3? Extension frames, likewise.</p>
<p id="rfc.section.3.1.4.p.2">Being on QUIC stream 3 has the same semantics as being on HTTP/2 stream 0; these frames likewise could omit the stream number from the framing.  We might reuse the frame type space and have alternate interpretations when on the &#8220;connection management&#8221; stream.</p>
<p id="rfc.section.3.1.4.p.3">TBD.</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#http-message-exchanges" id="http-message-exchanges">HTTP Message Exchanges</a></h1>
<p id="rfc.section.3.2.p.1">A client sends an HTTP request on a new QUIC stream. A server sends an HTTP response on the same stream as the request.</p>
<p id="rfc.section.3.2.p.2">An HTTP message (request or response) consists of:</p>
<p/>

<ol>
  <li>for a response only, zero or more header blocks (a sequence of HEADERS frames with End Header Block set on the last) containing the message headers of informational (1xx) HTTP responses (see <a href="#RFC7230">[RFC7230]</a>, Section 3.2 and <a href="#RFC7231">[RFC7231]</a>, Section 6.2),</li>
  <li>one header block containing the message headers (see <a href="#RFC7230">[RFC7230]</a>, Section 3.2),</li>
  <li>zero or more DATA frames containing the payload body (see <a href="#RFC7230">[RFC7230]</a>, Section 3.3), and</li>
  <li>optionally, one header block containing the trailer-part, if present (see <a href="#RFC7230">[RFC7230]</a>, Section 4.1.2).</li>
</ol>
<p id="rfc.section.3.2.p.4">Following the last frame in the sequence, the QUIC stream is half-closed in the sender&#8217;s direction.</p>
<p id="rfc.section.3.2.p.5">DATA frames are used to carry message payloads. The &#8220;chunked&#8221; transfer encoding defined in Section 4.1 of <a href="#RFC7230">[RFC7230]</a> MUST NOT be used.</p>
<p id="rfc.section.3.2.p.6">Trailing header fields are carried in a header block following the body.  Such a header block is a sequence of HEADERS frames with End Header Block set on the last frame. Header blocks after the first but before the end of the stream are invalid and MUST be discarded (after decoding, to maintain QPACK decoder state).</p>
<p id="rfc.section.3.2.p.7">A header block can only appear at the start or end of a stream. An endpoint that receives a HEADERS frame after receiving a final (non- informational) status code MUST treat the corresponding request or response as malformed (Section 8.1.2.6).</p>
<p id="rfc.section.3.2.p.8">An HTTP request/response exchange fully consumes a single stream. After sending a request, a client closes the stream for sending; after sending a response, the server closes its stream for sending and the QUIC stream is fully closed. A response starts with a HEADERS frame and ends with a frame bearing END_STREAM, which places the stream in the &#8220;closed&#8221; state.</p>
<p id="rfc.section.3.2.p.9">A server can send a complete response prior to the client sending an entire request if the response does not depend on any portion of the request that has not been sent and received. When this is true, a server MAY request that the client abort transmission of a request without error by sending a RST_STREAM with an error code of NO_ERROR after sending a complete response and closing its stream. Clients MUST NOT discard responses as a result of receiving such a RST_STREAM, though clients can always discard responses at their discretion for other reasons.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#performance-considerations" id="performance-considerations">Performance Considerations</a></h1>
<p id="rfc.section.4.p.1">While QPACK is designed to minimize head-of-line blocking between streams on header decoding, there are some situations in which lost or delayed packets can block decoding of subsequent frames:</p>
<p/>

<ul>
  <li>References to indexed entries will block if the frame containing the entry definition is lost or delayed.</li>
  <li>If the frame initiating a phase change is lost or delayed, the decoder cannot process any indexed entries from the new phase until it arrives.</li>
</ul>
<p id="rfc.section.4.p.3">Encoders MAY choose to avoid references to these entries until the packet containing the definiting frame has been acknowledged by the decoder. In both cases, the resulting literal values used instead will reduce compression efficiency, but avoid blocking either the encoder or decoder.</p>
<p id="rfc.section.4.p.4">If frames from the previous phase have been lost or delayed, the decoder will delay acknowledging and completing a phase change. The encoder can find itself in a state where no new entries can be added to the dynamic table. The encoder is not blocked, but will need to use literal values until the phase change completes.</p>
<p id="rfc.section.4.p.5">Memory-constrained implementations MAY delay processing of <em>all</em> QPACK frames from the new phase until the previous phase has completed, in order to avoid maintaining two tables in parallel. Doing so would introduce a connection-wide delay, so encoders SHOULD minimize the frequency of phase changes.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.5.p.1">The security considerations for QPACK are believed to be the same as for HPACK, with one addition.  An encoder could maliciously or mistakenly claiming to have encoded more frames than it has actually sent while initiating a phase-change.  Decoders SHOULD defend themselves against such implementations by considering it a connection error if the phase change cannot be completed within a reasonable number of RTTs, or if the transport reports that there is no unreceived data still pending.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.6.p.1">This document currently makes no request of IANA, but probably should.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#ack" id="ack">Acknowledgements</a></h1>
<p id="rfc.section.7.p.1">This draft draws heavily on the text of <a href="#RFC7540">[RFC7540]</a>, <a href="#RFC7541">[RFC7541]</a>, and <a href="#I-D.shade-quic-http2-mapping">[I-D.shade-quic-http2-mapping]</a>.  The indirect input of those authors is gratefully acknowledged, as well as ideas stolen from:</p>
<p/>

<ul>
  <li>Jana Iyengar</li>
  <li>Patrick McManus</li>
  <li>Martin Thomson</li>
  <li>Charles &#8216;Buck&#8217; Krasic</li>
</ul>
<h1 id="rfc.references"><a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.hamilton-quic-transport-protocol">[I-D.hamilton-quic-transport-protocol]</b>
      </td>
      <td class="top"><a>Hamilton, R.</a>, <a>Iyengar, J.</a>, <a>Swett, I.</a> and <a>A. Wilk</a>, "<a href="http://tools.ietf.org/html/draft-hamilton-quic-transport-protocol-01">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-hamilton-quic-transport-protocol-01, October 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.shade-quic-http2-mapping">[I-D.shade-quic-http2-mapping]</b>
      </td>
      <td class="top"><a>Shade, R.</a> and <a>M. Warres</a>, "<a href="http://tools.ietf.org/html/draft-shade-quic-http2-mapping-00">HTTP/2 Semantics Using The QUIC Transport Protocol</a>", Internet-Draft draft-shade-quic-http2-mapping-00, July 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7230">[RFC7230]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7231">[RFC7231]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7541">[RFC7541]</b>
      </td>
      <td class="top"><a>Peon, R.</a> and <a>H. Ruellan</a>, "<a href="http://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>", RFC 7541, DOI 10.17487/RFC7541, May 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC7540">[RFC7540]</b>
      </td>
      <td class="top"><a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> 
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:michael.bishop@microsoft.com">michael.bishop@microsoft.com</a></span>

  </address>
</div>

</body>
</html>
