<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Inspection of Encrypted HTTP Traffic by Proxies</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Existing HTTP Proxy Usage"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Insisting on Inspection"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Providing Inspected Access"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 The INSPECTED_CONNECT method"/>
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Tunnel Establishment"/>
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Use of Encrypted Tunnel"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Security Considerations"/>
<link href="#rfc.section.5" rel="Chapter" title="5 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="6 References"/>
<link href="#rfc.references.1" rel="Chapter" title="6.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="6.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Bishop, M." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-bishop-httpbis-proxy-inspection-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-3-2" />
  <meta name="dct.abstract" content="The IETF has unilaterally opposed the standardization of &#8220;wiretapping&#8221; features in protocols (" />
  <meta name="description" content="The IETF has unilaterally opposed the standardization of &#8220;wiretapping&#8221; features in protocols (" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">XMPP Working Group</td>
  <td class="right">M. Bishop</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Microsoft</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">March 2, 2017</td>
</tr>
<tr>
  <td class="left">Expires: September 3, 2017</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Inspection of Encrypted HTTP Traffic by Proxies<br />
  <span class="filename">draft-bishop-httpbis-proxy-inspection-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>The IETF has unilaterally opposed the standardization of &#8220;wiretapping&#8221; features in protocols (<a href="#RFC2840">[RFC2840]</a>).  At the same time, there exist legitimate scenarios in which entities might be required for various reasons to inspect traffic sent from and to clients under their control.  For a number of reasons, such inspection cannot always occur within the user agent.  This document describes mechanisms whereby an explicitly configured proxy can, with the consent of the user agent, examine the contents of client network traffic.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 3, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Existing HTTP Proxy Usage</a></li>
</ul><li>2.   <a href="#rfc.section.2">Insisting on Inspection</a></li>
<li>3.   <a href="#rfc.section.3">Providing Inspected Access</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">The INSPECTED_CONNECT method</a></li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">Tunnel Establishment</a></li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Use of Encrypted Tunnel</a></li>
</ul></ul><li>4.   <a href="#rfc.section.4">Security Considerations</a></li>
<li>5.   <a href="#rfc.section.5">IANA Considerations</a></li>
<li>6.   <a href="#rfc.references">References</a></li>
<ul><li>6.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>6.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Author's Address</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">Vendors of HTTP proxies (see <a href="#RFC7230">[RFC7230]</a>, Section 2.3) have historically provided a number of services at the edge of managed networks.  Whether due to virus scanning, blocking exfiltration of corporate data, or limiting what resources can be accessed from machines under their authority, one of the most common reasons to install an intermediary is blocking requests.</p>
<p id="rfc.section.1.p.2">At the same time, increasing desires for privacy and security online have increased the required use of TLS for encryption and authentication <a href="#RFC6797">[RFC6797]</a>.  The only solution available to proxy vendors so far has been to deploy man-in-the-middle proxies, intercepting either the raw traffic or the contents of HTTP CONNECT tunnels <a href="#RFC7231">[RFC7231]</a> and responding with forged certificates from a captive private Certificate Authority.  (Because the clients in these scenarios are owned and managed by the same entity as the proxy, the clients are configured to trust this Certificate Authority.)</p>
<p id="rfc.section.1.p.3">This has created an arms-race between user agents and proxies:  User agents deploy mechanisms such as certificate key pinning <a href="#RFC7469">[RFC7469]</a> to detect man-in-the-middle certificates; enterprises request management mechanisms to disable this feature.  Because the entities performing the monitoring often have legal mandates to inspect the traffic, they will continue to attempt to do so.  Because user agents correctly prioritize the security and privacy of their users, they will continue to invest in mechanisms to detect tampering with connections.</p>
<p id="rfc.section.1.p.4">This document proposes a mechanism whereby a configured HTTP proxy can inform clients that it will not permit a particular connection without being able to inspect the contents.  Clients are fully aware of the proxy&#8217;s inspection, and servers have the option to be aware of the proxy&#8217;s inspection as well.  Participating servers are able to achieve an integrity-protected connection with the client which can be inspected only by the proxy.</p>
<p id="rfc.section.1.p.5">This enables clients, servers, and proxies to make informed decisions about whether to proceed with a connection given a known level of privacy.  It also permits user agents to provide detailed information to users about the proxy and its level of access to their traffic.  Because at least one, and potentially all, parties are aware that the inspection is occurring, this does not qualify as &#8220;wiretapping&#8221; as defined by <a href="#RFC2840">[RFC2840]</a>.</p>
<p id="rfc.section.1.p.6">This document specifically addresses the case where the same entity exercise management over both the client devices and the proxy server, and assumes some ability to configure the clients and enforce application capabilities.  The case where no such administrative control exists is specifically outside the scope of this document.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#existing-http-proxy-usage" id="existing-http-proxy-usage">Existing HTTP Proxy Usage</a></h1>
<p id="rfc.section.1.1.p.1">When an explicitly-configured HTTP proxy is in use, HTTP clients make requests in two ways:</p>
<p/>

<ul>
  <li>Regular HTTP requests in absolute-form (see <a href="#RFC7230">[RFC7230]</a>, Section 5.3.2), e.g.  GET http://www.example.com/</li>
  <li>CONNECT requests in authority-form (see <a href="#RFC7230">[RFC7230]</a>, Section 5.3.3), e.g.  CONNECT www.example.com:443, over which the client performs a TLS exchange</li>
</ul>
<p id="rfc.section.1.1.p.3">While not mandated by the HTTP specification, nearly all clients use absolute-form requests (in which the proxy sees the request and response) for &#8220;http&#8221;-schemed origins and authority-form CONNECT requests (in which the proxy sees only a TLS connection) for &#8220;https&#8221;-schemed origins.</p>
<p id="rfc.section.1.1.p.4">For proxies which only permit requests in which they can inspect the content of the request and response, they typically respond to CONNECT requests with a forged certificate for the end server.  The client&#8217;s requests (if deemed acceptable) are then relayed to the end server, just as they would have been had the client made an absolute-form request for the resource.</p>
<p id="rfc.section.1.1.p.5">The client might be able to detect that the server has done so using mechanisms such as certificate pinning, both through pre-loaded lists of known site pins and the HTTP Public-Key-Pinning protocol <a href="#RFC7469">[RFC7469]</a>.  However, they cannot easily distinguish an inspecting proxy from an attack, despite the fact that they have been explicitly configured to trust the proxy.  To &#8220;solve&#8221; this, clients are typically configured to disable mechanisms which would enable them to detect an attack.</p>
<p id="rfc.section.1.1.p.6">A client could legitimately make an absolute-form request for an &#8220;https&#8221; response. However, the client would be unable to see the certificate of the origin server, and would therefore be unable to achieve the level of authentication generally expected from &#8220;https&#8221; resources.  When the client is configured to trust the proxy, this could be considered acceptable (since the proxy will presumably validate the certificate), but opens the client to attacks from the proxy.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#insisting-on-inspection" id="insisting-on-inspection">Insisting on Inspection</a></h1>
<p id="rfc.section.2.p.1">Proxies which require access to the request currently have no way to request it.  Proxies which implement the remainder of this specification MAY permit uninspected TLS connections to any endpoint.  In this case, CONNECT requests from clients should continue to succeed and result in an actual tunnel to the origin server as specified in <a href="#RFC7231">[RFC7231]</a>.</p>
<p id="rfc.section.2.p.2">If a proxy is unwilling to allow a CONNECT request, but would allow the client to make requests to the specified host if it were able to see the unencrypted data, the server SHOULD respond to the CONNECT request with a status code 405.  In the Allow header, the proxy MUST include the INSPECTED_CONNECT method defined in <a href="#method-inspected-connect">Section 3.1</a>.</p>
<p id="rfc.section.2.p.3">User agents, with appropriate user consent, MAY retry the request using INSPECTED_CONNECT rather than CONNECT.  Note that user agents which do not support INSPECTED_CONNECT will be unable to proceed.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#providing-inspected-access" id="providing-inspected-access">Providing Inspected Access</a></h1>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#method-inspected-connect" id="method-inspected-connect">The INSPECTED_CONNECT method</a></h1>
<p id="rfc.section.3.1.p.1">The INSPECTED_CONNECT method requests that the recipient establish an encrypted tunnel to the destination origin server identified by the request-target.  If successful, the client will use this tunnel as specified by this document.  The proxy will inspect and forward packets in both directions until the tunnel is closed, but will not modify packets.  Based on the results of its inspection, the server MAY terminate the tunnel at any time.</p>
<p id="rfc.section.3.1.p.2">INSPECTED_CONNECT is intended only for use in requests to a proxy.  An origin server that receives a INSPECTED_CONNECT request for itself MAY respond with a 2xx (Successful) status code to indicate that a connection is established.  However, most origin servers will not implement INSPECTED_CONNECT.</p>
<p id="rfc.section.3.1.p.3">A client sending an INSPECTED_CONNECT request MUST send the authority form of request-target (Section&#160;5.3 of <a href="#RFC7230">[RFC7230]</a>); i.e., the request-target consists of only the host name and port number of the tunnel destination, separated by a colon.  The client MUST also include the ALPN header <a href="#RFC7639">[RFC7639]</a>, identifying the protocol it proposes to speak to the tunnel destination.</p>
<p id="rfc.section.3.1.p.4">For example,</p>
<pre>
INSPECTED_CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
ALPN: h2, http%2F1.1
</pre>
<p id="rfc.section.3.1.p.5">The server attempts to establish one of two tunnel types, as described in <a href="#tunnel-establishment">Section 3.1.1</a>, and reports the tunnel type to the client as described in <a href="#status-codes">Section 3.1.2</a>.</p>
<p id="rfc.section.3.1.p.6">A tunnel is closed when a tunnel intermediary detects that either side has closed its connection: the intermediary MUST attempt to send any outstanding data that came from the closed side to the other side, close both connections, and then discard any remaining data left undelivered.</p>
<p id="rfc.section.3.1.p.7">Proxy authentication might be used to establish the authority to create a tunnel.  For example,</p>
<pre>
INSPECTED_CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
ALPN: h2, http%2F1.1
Proxy-Authorization: basic aGVsbG86d29ybGQ=
</pre>
<p id="rfc.section.3.1.p.8">There are significant risks in establishing a tunnel to arbitrary servers, particularly when the destination is a well-known or reserved TCP port that is not intended for Web traffic.  For example, an INSPECTED_CONNECT to a request-target of &#8220;example.com:25&#8221; would suggest that the proxy connect to the reserved port for SMTP traffic; if allowed, that could trick the proxy into relaying spam email. Proxies that support INSPECTED_CONNECT SHOULD restrict its use to a limited set of known ports or a configurable whitelist of safe request targets, and SHOULD verify that the client is actually speaking the protocol which it proposed to speak.</p>
<p id="rfc.section.3.1.p.9">A server MUST NOT send any Transfer-Encoding or Content-Length header fields in a 2xx (Successful) response to INSPECTED_CONNECT.  A client MUST ignore any Content-Length or Transfer-Encoding header fields received in a successful response to INSPECTED_CONNECT.</p>
<p id="rfc.section.3.1.p.10">A payload within an INSPECTED_CONNECT request message has no defined semantics; sending a payload body on an INSPECTED_CONNECT request might cause some implementations to reject the request.</p>
<p id="rfc.section.3.1.p.11">Responses to the INSPECTED_CONNECT method are not cacheable.</p>
<h1 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#tunnel-establishment" id="tunnel-establishment">Tunnel Establishment</a></h1>
<p id="rfc.section.3.1.1.p.1">In handling an INSPECTED_CONNECT request, the server MUST attempt to establish an encrypted tunnel to the identified origin server.  The encrypted tunnel MUST use TLS <a href="#RFC5426">[RFC5426]</a> and MUST include the ALPN extension <a href="#RFC7301">[RFC7301]</a>.   The proxy MAY remove from the client&#8217;s ALPN list protocols it is not prepared to inspect.</p>
<p id="rfc.section.3.1.1.p.2">The protocols proposed in ALPN MUST include each acceptable protocol in the client&#8217;s ALPN header, prefixed with &#8220;inspected_&#8221;.  That is, if the client sent the ALPN header &#8220;h2, http%2F1.1&#8221;, the server would include the ALPN tokens &#8220;inspected_h2&#8221; and &#8220;inspected_http/1.1&#8221;. Optionally, the proxy MAY include protocols it is capable of using to relay requests from clients.</p>
<p id="rfc.section.3.1.1.p.3">If the origin server supports inspected tunnels and is willing to accept an inspected connection, it SHOULD select one of the &#8220;inspected_&#8221; ALPN tokens.  If the origin server is not willing to accept inspection, it SHOULD respond with a fatal &#8220;no_application_protocol&#8221; alert.</p>
<p id="rfc.section.3.1.1.p.4">An origin server SHOULD NOT select a non-&#8220;inspected_&#8221; token if it implements this protocol and an &#8220;inspected_&#8221; token is present.  Selection of an uninspected protocol token indicates that the origin server is unaware of inspection.  The proxy MUST NOT consider the tunnel connection successful in this case, but MAY retain the completed TLS connection to relay client request.  Proxies MAY cache that origin servers do not support this protocol, in order to return errors more quickly when appropriate.</p>
<p id="rfc.section.3.1.1.p.5">The proxy MUST validate the certificate presented by the origin server, and MUST NOT consider the tunnel successfully established if the certificate cannot be validated.</p>
<p id="rfc.section.3.1.1.p.6">If a proxy cannot reach the origin server directly, it MAY establish its own tunneled connection using CONNECT or INSPECTED_CONNECT as needed.</p>
<h1 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#status-codes" id="status-codes">Use of Encrypted Tunnel</a></h1>
<p id="rfc.section.3.1.2.p.1">If the origin server accepts the connection, the proxy completes the INSPECTED_CONNECT request with status code 200 (Success).  The remainder of the connection (in HTTP/1.1) or stream (in HTTP/2) is a tunnel which is encrypted between the proxy and the origin server.  The proxy&#8217;s response SHOULD include an ALPN header specifying the protocol selected by the origin server on the proxy&#8217;s connection.</p>
<p id="rfc.section.3.1.2.p.2">If the selected protocol is an &#8220;inspected_&#8221; token, the client MUST proceed by establishing a TLS <a href="#RFC5246">[RFC5246]</a> connection, but proposing only NULL encryption.  (A non-NULL key exchange and MAC MUST be negotiated.)  The client MUST include the ALPN extension and the token for the uninspected protocol on this inner TLS connection.  The server MUST accept the client&#8217;s NULL encryption.  Confidentiality is provided by the TLS session between the proxy and the origin server.</p>
<p id="rfc.section.3.1.2.p.3">If the origin server did not demonstrate support for this protocol, the server MUST return a status code 502 (Bad Gateway).  The client MAY then issue requests for &#8220;https&#8221; resources directly to the proxy using absolute-form, but cannot have assurance that the proxy is not modifying the responses.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.4.p.1">This protocol intentionally allows multiple parties to an HTTP exchange to make security trade-offs.  Proxies have the choice of permitting clients to make fully-encrypted connections to certain endpoints (existing CONNECT).  Alternatively, the proxy can force the client to choose between disclosing the contents of the exchange or not performing the exchange.</p>
<p id="rfc.section.4.p.2">Clients that choose to disclose the contents of the exchange face a second junction based on origin server support (and, potentially, the honesty of the proxy).  When the origin server supports this protocol, the client is able to receive and validate the origin server&#8217;s certificate.  The client SHOULD apply all available tampering-detection mechanisms in this circumstance and MAY exclude administratively-configured root certificates from the set considered trusted.</p>
<p id="rfc.section.4.p.3">If the origin server does not support this protocol, the client will be unable to verify the server&#8217;s certificate itself.  It MAY trust the proxy&#8217;s validation of the certificate, or refuse to proceed with the request.</p>
<p id="rfc.section.4.p.4">In the event that multiple proxies must be traversed to reach the origin server, the client can only verify the identity of the first proxy.  Even if no other proxy server is involved in the connection, the proxy is fully able to relay the contents of the client&#8217;s connection to other parties in real time or to store them and provide them at a later time.  This is inherent in the power of inspection.</p>
<p id="rfc.section.4.p.5">In each of these cases, user consent MUST be obtained for anything less than an end-to-end encrypted and authenticated connection.  As a convenience, this consent MAY be persistent for a given proxy server, but some indication SHOULD be provided to the user at all times when a connection is known to be inspected.</p>
<p id="rfc.section.4.p.6">When CONNECT is used to establish a tunnel via a proxy, the contents of the tunnel are typically encrypted end-to-end.  As a result, the use of TLS when connecting to the proxy is less critical.  The INSPECTED_CONNECT method provides encryption only between the proxy and the origin server; as a result, it SHOULD only be used over a TLS connection to the proxy.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.5.p.1">If it had even a snowball&#8217;s chance of becoming an RFC, this document would need to register:</p>
<p/>

<ul>
  <li>the INSPECTED_CONNECT method,</li>
  <li>the inspected_* ALPN token collection, and</li>
  <li>possibly the &#8220;ALPN&#8221; header as a response header.</li>
</ul>
<p id="rfc.section.5.p.3">But as that is not the case, this document makes no requests of IANA.</p>
<h1 id="rfc.references"><a href="#rfc.references">6.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">6.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5426">[RFC5426]</b>
      </td>
      <td class="top"><a>Okmianski, A.</a>, "<a href="http://tools.ietf.org/html/rfc5426">Transmission of Syslog Messages over UDP</a>", RFC 5426, DOI 10.17487/RFC5426, March 2009.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7230">[RFC7230]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7231">[RFC7231]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7301">[RFC7301]</b>
      </td>
      <td class="top"><a>Friedl, S.</a>, <a>Popov, A.</a>, <a>Langley, A.</a> and <a>E. Stephan</a>, "<a href="http://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>", RFC 7301, DOI 10.17487/RFC7301, July 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7639">[RFC7639]</b>
      </td>
      <td class="top"><a>Hutton, A.</a>, <a>Uberti, J.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7639">The ALPN HTTP Header Field</a>", RFC 7639, DOI 10.17487/RFC7639, August 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">6.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2840">[RFC2840]</b>
      </td>
      <td class="top"><a>Altman, J.</a> and <a>F. da Cruz</a>, "<a href="http://tools.ietf.org/html/rfc2840">TELNET KERMIT OPTION</a>", RFC 2840, DOI 10.17487/RFC2840, May 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6797">[RFC6797]</b>
      </td>
      <td class="top"><a>Hodges, J.</a>, <a>Jackson, C.</a> and <a>A. Barth</a>, "<a href="http://tools.ietf.org/html/rfc6797">HTTP Strict Transport Security (HSTS)</a>", RFC 6797, DOI 10.17487/RFC6797, November 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7469">[RFC7469]</b>
      </td>
      <td class="top"><a>Evans, C.</a>, <a>Palmer, C.</a> and <a>R. Sleevi</a>, "<a href="http://tools.ietf.org/html/rfc7469">Public Key Pinning Extension for HTTP</a>", RFC 7469, DOI 10.17487/RFC7469, April 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> 
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:michael.bishop@microsoft.com">michael.bishop@microsoft.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/MikeBishop/http-misc-extensions">Fork me on GitHub</a></div></div>
</body>
</html>
