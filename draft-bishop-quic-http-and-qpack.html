<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Header Compression for HTTP/QUIC</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 525px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 15px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
    overscroll-behavior: contain;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 25px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 QPACK - Concepts">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Changes to Static and Dynamic Tables">
<link href="#rfc.section.2.1.1" rel="Chapter" title="2.1.1 Dynamic Table State Synchronization">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Encoding Constraints">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Permitted References">
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Header Table Size">
<link href="#rfc.section.3" rel="Chapter" title="3 Wire Format">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Feedback Stream">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 HEADERS_DONE">
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 ACK_FLUSH">
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 DROP">
<link href="#rfc.section.3.1.4" rel="Chapter" title="3.1.4 ACK_DROP">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Checkpoint Streams">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 INSERT">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 TOUCH">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Request Streams">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Indexed Header Field Representation">
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 Literal Header Field Representation">
<link href="#rfc.section.4" rel="Chapter" title="4 Use in HTTP/QUIC">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 SETTING_QPACK_BLOCKING_PERMITTED">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 SETTING_QPACK_INITIAL_CHECKPOINT">
<link href="#rfc.section.5" rel="Chapter" title="5 Implementation trade-offs">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Compression Efficiency versus Blocking Avoidance">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Timely State Transitions versus Decoder Complexity">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Settings">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Errors">
<link href="#rfc.section.8" rel="Chapter" title="8 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.8.2 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Bishop, M." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-bishop-quic-http-and-qpack-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-12-15" />
  <meta name="dct.abstract" content="HTTP/2 " />
  <meta name="description" content="HTTP/2 " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">QUIC Working Group</td>
<td class="right">M. Bishop</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Akamai</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">December 15, 2017</td>
</tr>
<tr>
<td class="left">Expires: June 18, 2018</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Header Compression for HTTP/QUIC<br />
  <span class="filename">draft-bishop-quic-http-and-qpack-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>HTTP/2 <a href="#RFC7540" class="xref">[RFC7540]</a> uses HPACK <a href="#RFC7541" class="xref">[RFC7541]</a> for header compression. However, HPACK relies on the in-order message-based semantics of the HTTP/2 framing layer in order to function.  Messages can only be successfully decoded if processed by the decoder in the same order as generated by the encoder.  This draft refines HPACK to loosen the ordering requirements for use over QUIC <a href="#I-D.ietf-quic-transport" class="xref">[I-D.ietf-quic-transport]</a>.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on June 18, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Terminology</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">QPACK - Concepts</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Changes to Static and Dynamic Tables</a>
</li>
<ul><li>2.1.1.   <a href="#rfc.section.2.1.1">Dynamic Table State Synchronization</a>
</li>
</ul><li>2.2.   <a href="#rfc.section.2.2">Encoding Constraints</a>
</li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Permitted References</a>
</li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Header Table Size</a>
</li>
</ul></ul><li>3.   <a href="#rfc.section.3">Wire Format</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Feedback Stream</a>
</li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">HEADERS_DONE</a>
</li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">ACK_FLUSH</a>
</li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">DROP</a>
</li>
<li>3.1.4.   <a href="#rfc.section.3.1.4">ACK_DROP</a>
</li>
</ul><li>3.2.   <a href="#rfc.section.3.2">Checkpoint Streams</a>
</li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">INSERT</a>
</li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">TOUCH</a>
</li>
</ul><li>3.3.   <a href="#rfc.section.3.3">Request Streams</a>
</li>
<ul><li>3.3.1.   <a href="#rfc.section.3.3.1">Indexed Header Field Representation</a>
</li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">Literal Header Field Representation</a>
</li>
</ul></ul><li>4.   <a href="#rfc.section.4">Use in HTTP/QUIC</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">SETTING_QPACK_BLOCKING_PERMITTED</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">SETTING_QPACK_INITIAL_CHECKPOINT</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Implementation trade-offs</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Compression Efficiency versus Blocking Avoidance</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Timely State Transitions versus Decoder Complexity</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Settings</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Errors</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Acknowledgements</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<ul><li>9.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#problems" id="problems">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">HPACK has a number of features that were intended to provide performance advantages to HTTP/2, but which don&#8217;t live well in an out-of-order environment such as that provided by QUIC.</p>
<p id="rfc.section.1.p.2">The largest challenge is the fact that elements are referenced by a very fluid index. Not only is the index implicit when an item is added to the header table, the index will change without notice as other items are added to the header table. Static entries occupy the first 61 values, followed by dynamic entries. A newly-added dynamic entry would cause older dynamic entries to be evicted, and the retained items are then renumbered beginning with 62. This means that, without processing all preceding header sets, no index into the dynamic table can be interpreted, and the index of a given entry cannot be predicted.</p>
<p id="rfc.section.1.p.3">Any solution to the above will almost certainly fall afoul of the memory constraints the decompressor imposes. The automatic eviction of entries is done based on the compressor&#8217;s declared dynamic table size, which MUST be less than the maximum permitted by the decompressor (and relayed using an HTTP/2 SETTINGS value).</p>
<p id="rfc.section.1.p.4">Further, streams in QUIC are lossy in the presence of stream resets.  While HTTP/2 (via TCP) guarantees the delivery of all previously-sent data on a stream even if that stream is reset, QUIC does not retransmit lost frames if a stream has been reset, and may discard data which has not yet been delivered to the application.</p>
<p id="rfc.section.1.p.5">Early versions of QPACK were small deltas of HPACK to introduce order-resiliency. Recent versions depart from HPACK more substantially to add resilience against reset message streams and reduce the impact of head-of-line blocking.</p>
<p id="rfc.section.1.p.6">In the following sections, this document proposes a successor to HPACK which makes different trade-offs, enabling partial out-of-order interpretation and bounded memory consumption with minimal head-of-line blocking. None of the proposed improvements to HPACK (strongly-typed fields, binary compression of common header syntax) are currently included, but certainly could be.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#Terminology" id="Terminology">Terminology</a>
</h1>
<p id="rfc.section.1.1.p.1">In this document, the key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; are to be interpreted as described in BCP 14, <a href="#RFC2119" class="xref">[RFC2119]</a> and indicate requirement levels for compliant implementations.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#QPACK" id="QPACK">QPACK - Concepts</a>
</h1>
<p id="rfc.section.2.p.1">HPACK combines header table modification and message header emission in a single sequence of coded bytes.  QPACK bifurcates these into three channels:</p>
<p></p>

<ul>
<li>Connection-wide sets of table update instructions sent on non-request streams</li>
<li>Connection-wide feedback on stream and checkpoint state on a single non-request stream</li>
<li>Non-modifying instructions which use the current header table state to encode message headers on request streams</li>
</ul>
<p id="rfc.section.2.p.3">Because the per-message instructions introduce no changes to the header table state, no state is lost if these instructions are discarded due to a stream reset.  Because the updates to the header table supply their own order controls (the checkpoint logic), they can be processed in any order and therefore delivered as messages using unidirectional QUIC streams.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#changes-to-static-and-dynamic-tables" id="changes-to-static-and-dynamic-tables">Changes to Static and Dynamic Tables</a>
</h1>
<p id="rfc.section.2.1.p.1">QPACK uses two tables for associating header fields to indexes. The static table is unchanged from <a href="#RFC7541" class="xref">[RFC7541]</a>. Unlike in <a href="#RFC7541" class="xref">[RFC7541]</a>, the tables are not concatenated, but are referenced separately.</p>
<p id="rfc.section.2.1.p.2">The dynamic table is a map from index to header field. Indices are arbitrary numbers between 1 and 2^27. Each insert instruction will specify the index being modified. While any index MAY be chosen for a new entry, smaller numbers will yield better compression performance.</p>
<p id="rfc.section.2.1.p.3">With decoder consent (see <a href="#setting-block" class="xref">Section 4.1</a>), it is possible for QPACK instructions to arrive which reference indices which have not yet been defined.  Such instructions MUST wait until the index definition has arrived. In order to guard against malicious peers, implementations supporting blocking SHOULD impose a time limit and treat expiration of the timer as a decoding error.</p>
<h1 id="rfc.section.2.1.1">
<a href="#rfc.section.2.1.1">2.1.1.</a> <a href="#checkpoints" id="checkpoints">Dynamic Table State Synchronization</a>
</h1>
<p id="rfc.section.2.1.1.p.1">In order to ensure table consistency, all modifications of the header table occur as separate messages rather than on request streams.  Request streams contain only indexed and literal header entries.</p>
<p id="rfc.section.2.1.1.p.2">No entries are automatically evicted from the dynamic table. Size management is purely the responsibility of the encoder, which MUST NOT exceed the declared memory size of the decoder.</p>
<p id="rfc.section.2.1.1.p.3">To simplify state management in the dynamic table, <em>checkpoints</em> are introduced.  A checkpoint is used to track entries added to the dynamic table and streams that reference those entries, rather than maintaining the full state of which streams reference which table entries.</p>
<p id="rfc.section.2.1.1.p.4">Checkpoints are unordered and have an identifier which MUST be unique among checkpoints which have not been dropped.  Each checkpoint has a unidirectional stream which begins with its identifier and contains a series of updates associated with that checkpoint.  These updates SHOULD be processed as they arrive; it is not necessary (and might not be desirable) to wait for all instructions associated with a checkpoint to arrive before beginning to process it.</p>
<p id="rfc.section.2.1.1.p.5">The feedback stream is used to relay state transitions to the peer. For example, when a decoder is done processing a header block, it signals this using the HEADERS_DONE message.  The encoder uses this information to track which checkpoints can be dropped.</p>
<h1 id="rfc.section.2.1.1.1">
<a href="#rfc.section.2.1.1.1">2.1.1.1.</a> <a href="#checkpoint-lifecycle" id="checkpoint-lifecycle">Checkpoint Lifecycle</a>
</h1>
<p id="rfc.section.2.1.1.1.p.1">A checkpoint is created by opening a new checkpoint stream.  This places the checkpoint in the NEW state for both encoder and decoder.  The encoder typically has at least one checkpoint in the NEW state.</p>
<p id="rfc.section.2.1.1.1.p.2">Flushing a checkpoint is a two-step operation.  First, the checkpoint stream is closed. At that time, the encoder&#8217;s NEW checkpoint becomes PENDING.  The decoder moves its NEW checkpoint directly to LIVE and responds with an ACK_FLUSH message on the feedback stream.  When the encoder receives this message, its PENDING checkpoint becomes LIVE.</p>
<p id="rfc.section.2.1.1.1.p.3">Unused entries are evicted indirectly, by dropping checkpoints. Before a checkpoint can be dropped, its state is changed to DYING.  Changing a checkpoint&#8217;s state to DYING allows the checkpoint to age out.  This is a strictly internal state on the encoder, and not visible to the decoder. A DYING checkpoint can be returned to LIVE at the encoder&#8217;s discretion if necessary.</p>
<p id="rfc.section.2.1.1.1.p.4">The encoder can change a DYING checkpoint to DEAD (sending a DROP instruction) when it is no longer referenced by any outstanding header blocks. The encoder sends the DROP command to the decoder when it declares a checkpoint DEAD.</p>
<p id="rfc.section.2.1.1.1.p.5">To ensure consistency, the decoder drops the corresponding checkpoint and responds with an ACK_DROP message only when it has fully received all instructions the encoder has issued up to that point.  The encoder drops the DEAD checkpoint upon receipt of the ACK_DROP message.</p>
<p id="rfc.section.2.1.1.1.p.6">When a checkpoint is dropped by encoder or decoder, the table entries it references are checked: if an entry is no longer referenced by any checkpoint, the entry is evicted.</p>
<p id="rfc.section.2.1.1.1.p.7">Dropping a checkpoint and the entries associated with it is not limited to just the oldest checkpoint; any DYING checkpoint &#8211; as long as state transition rules are followed &#8211; may be dropped.  This flexibility permits the encoder to use a number of strategies for entry eviction.</p>
<p id="rfc.section.2.1.1.1.p.8">As long as the maximum dynamic table size is observed, new checkpoints can be created; no upper limit on the number of checkpoints is specified.  A well-balanced spread of checkpoints permits the encoder to recycle entries effectively.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#encoding-constraints" id="encoding-constraints">Encoding Constraints</a>
</h1>
<h1 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#permitted-references" id="permitted-references">Permitted References</a>
</h1>
<p id="rfc.section.2.2.1.p.1">When encoding headers on a request stream, an encoder MAY reference any static table entry or any dynamic header table entry referenced by a LIVE checkpoint.  References to entries in NEW or PENDING checkpoints are permitted only if the client has set <samp>SETTING_QPACK_BLOCKING_PERMITTED</samp> (see <a href="#setting-block" class="xref">Section 4.1</a>).</p>
<p id="rfc.section.2.2.1.p.2">If a decoder receives a reference to an empty slot in the dynamic table but has not sent <samp>SETTING_QPACK_BLOCKING_PERMITTED</samp>, this MUST be treated as a stream error of type <samp>ERROR_QPACK_INVALID_REFERENCE</samp> if on a request stream. References to empty slots in the dynamic table on a checkpoint stream MUST be treated as a connection error of type <samp>ERROR_QPACK_INVALID_REFERENCE</samp>.</p>
<p id="rfc.section.2.2.1.p.3">References to DYING checkpoints are possible by returning the checkpoint to LIVE, but this is usually inadvisable.  Table entries contained only in a DEAD checkpoint can never be referenced.</p>
<h1 id="rfc.section.2.2.2">
<a href="#rfc.section.2.2.2">2.2.2.</a> <a href="#header-table-size" id="header-table-size">Header Table Size</a>
</h1>
<p id="rfc.section.2.2.2.p.1">As in HPACK, the dynamic table is constrained to the maximum size specified by the decoder. An attempt to add a header to the dynamic table or to create a new checkpoint which causes it to exceed the maximum size MUST be treated as an error by a decoder.  To enable encoders to reclaim space, encoders can drop old checkpoints (see <a href="#checkpoints" class="xref">Section 2.1.1</a>).</p>
<p id="rfc.section.2.2.2.p.2">The total table size is calculated as follows:</p>
<p></p>

<ul>
<li>The size of each entry is calculated as in HPACK</li>
<li>Each checkpoint that has not been removed, regardless of state, consumes 64 bytes</li>
</ul>
<h1 id="rfc.section.2.2.2.1">
<a href="#rfc.section.2.2.2.1">2.2.2.1.</a> <a href="#table-size-changes" id="table-size-changes">Table Size Changes</a>
</h1>
<p id="rfc.section.2.2.2.1.p.1">HTTP/QUIC prohibits mid-stream changes of settings.  As a result, only one table size change is possible:  From the value a client assumes during the 0-RTT flight to the actual value included in the server&#8217;s SETTINGS frame.  The assumed value is required to be either a server&#8217;s previous value or zero.  A server whose configuration has recently changed MAY overlook inadvertent violations of its maximum table size during the first round-trip.</p>
<p id="rfc.section.2.2.2.1.p.2">In the case that the value has increased, either from zero to a non-zero value or from the cached value to a higher value, no action is required by the client.  The encoder can simply begin using the additional space.  In the case that the value has decreased, the encoder MUST move checkpoints to the DYING state which, upon removal, would bring the table within the required size.</p>
<p id="rfc.section.2.2.2.1.p.3">Regardless of changes to header table size, the encoder MUST NOT create new checkpoints or add entries to the table which would result in a size greater than the maximum permitted.  This can imply that no additions are permitted while waiting for old checkpoints to complete.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#wire-format" id="wire-format">Wire Format</a>
</h1>
<p id="rfc.section.3.p.1">QPACK instructions occur on three stream types, each of which uses a separate instruction space.</p>
<p id="rfc.section.3.p.2">The feedback stream is a bidirectional server-initiated stream used for acknowledgement of actions and checkpoint state management.  Checkpoint streams are unidirectional streams from encoder to decoder. Both types of streams consist of a series of QPACK instructions with no message boundaries, preceded by a stream header for checkpoint streams.</p>
<p id="rfc.section.3.p.3">Finally, the contents of HEADERS and PUSH_PROMISE frames on request streams reference the QPACK table state.</p>
<p id="rfc.section.3.p.4">This section describes the instructions which are possible on each stream type.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#feedback-stream" id="feedback-stream">Feedback Stream</a>
</h1>
<p id="rfc.section.3.1.p.1">Stream 1, the first server-initiated bidirectional stream, is used as the feedback stream, since the client does not need to begin sending data on this stream until it has received data from the server.</p>
<p id="rfc.section.3.1.p.2">This stream is critical to the HTTP/QUIC connection, and carries a stream of the instructions defined in this section.  Data on this stream SHOULD be processed as soon as it arrives.</p>
<h1 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#headersdone" id="headersdone">HEADERS_DONE</a>
</h1>
<p id="rfc.section.3.1.1.p.1">When the decoder has processed a frame containing header emission instructions (<a href="#request-streams" class="xref">Section 3.3</a>, HEADERS or PUSH_PROMISE frames) on a stream, it MUST emit a HEADERS_DONE message on the feedback stream.  The same Stream ID can be identified multiple times, as multiple header-containing blocks can be sent on a single stream in the case of intermediate responses, trailers, pushed requests, etc.</p>
<p id="rfc.section.3.1.1.p.2">Since header frames on a request stream are received and processed in order, this gives the encoder precise feedback on which header blocks within a stream have been fully processed.  This information can then be used to correctly track outstanding stream references to checkpoints.</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |       Stream ID (7+)      |
+---+---------------------------+
</pre>
<p class="figure">HEADERS_DONE instruction</p>
<h1 id="rfc.section.3.1.2">
<a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#ackflush" id="ackflush">ACK_FLUSH</a>
</h1>
<p id="rfc.section.3.1.2.p.1">When the decoder has finished processing all instructions that make up a checkpoint, it MUST indicate successful processing to the encoder by emitting an ACK_FLUSH instruction on the feedback stream.</p>
<p id="rfc.section.3.1.2.p.2">Upon emitting an ACK_FLUSH, the checkpoint transitions from NEW to LIVE on the decoder. Upon receipt of an ACK_FLUSH, the checkpoint transitions from PENDING to LIVE on the encoder.</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | Checkpoint ID (5+)|
+---+---------------------------+
</pre>
<p class="figure">ACK_FLUSH instruction</p>
<h1 id="rfc.section.3.1.3">
<a href="#rfc.section.3.1.3">3.1.3.</a> <a href="#drop" id="drop">DROP</a>
</h1>
<p id="rfc.section.3.1.3.p.1">When an encoder has received sufficient HEADERS_DONE messages to know that a DYING checkpoint has no outstanding references, it emits a DROP instruction to inform the decoder that the checkpoint can be removed.  Upon sending a DROP instruction, a DYING checkpoint becomes DEAD.  The DROP instruction also includes the IDs of any PENDING or NEW checkpoints which reference entries contained in the checkpoint being dropped. The <samp>L</samp> bit in each byte indicates whether another checkpoint ID follows (L=0) or this is the final byte of the DROP instruction (L=1).</p>
<p id="rfc.section.3.1.3.p.2">Upon receiving a DROP instruction, if all listed checkpoints have been fully processed (transitioned from NEW to LIVE), the identified LIVE checkpoint is immediately removed from the decoder state and an ACK_DROP instruction is emitted.  Otherwise, the decoder saves the DROP instruction until other checkpoints become LIVE.</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | L | Checkpoint ID (5+)|
+---+---+---+-------------------+
| L |      Checkpoint (7+)      |
+---+---------------------------+
| L |      Checkpoint (7+)      |
+---+---------------------------+
|              ...              |
+-------------------------------+
</pre>
<p class="figure">DROP instruction</p>
<h1 id="rfc.section.3.1.4">
<a href="#rfc.section.3.1.4">3.1.4.</a> <a href="#ackdrop" id="ackdrop">ACK_DROP</a>
</h1>
<p id="rfc.section.3.1.4.p.1">When a decoder receives a DROP instruction, it removes the referenced checkpoint from its state and clears any table entries which were referenced only by that checkpoint.  It then emits an ACK_DROP instruction.  When an encoder receives an ACK_DROP instruction, it removes the corresponding DEAD checkpoint from its state and clears any table entries which were referenced only by that checkpoint.</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 | 1 | Checkpoint ID (5+)|
+---+---+---+-------------------+
</pre>
<p class="figure">ACK_DROP instruction</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#checkpoint-streams" id="checkpoint-streams">Checkpoint Streams</a>
</h1>
<p id="rfc.section.3.2.p.1">Each checkpoint stream indicates the creation and content of a NEW checkpoint.  Each checkpoint has an ID; these IDs are chosen arbitrarily by the encoder, though lower values SHOULD be preferred.  IDs of checkpoints which have been dropped MAY be reused for future NEW checkpoints.</p>
<p id="rfc.section.3.2.p.2">When the encoder has finished writing all data on the stream, it changes the checkpoint to PENDING.  When the decoder has received and processed all data on the stream, it changes the checkpoint to LIVE and generates an ACK_FLUSH.</p>
<p id="rfc.section.3.2.p.3">Unidirectional streams in HTTP/QUIC begin with a stream header indicating the nature of the stream content; the identifier for QPACK checkpoints is 0x4B.</p>
<p></p>

<ul class="empty"><li>
<strong>Note to readers:</strong> This header does not currently exist in the main draft, but has manifested in several PRs, and would need to be resurrected.</li></ul>
<p id="rfc.section.3.2.p.5">Following the stream header, a checkpoint stream contains its checkpoint ID as an 8-bit prefix integer. The remainder of the stream&#8217;s data consists of the instructions defined in this section.</p>
<p id="rfc.section.3.2.p.6">Data on checkpoint streams SHOULD be processed as soon as it arrives.  If multiple checkpoint streams are received at once, a decoder SHOULD process data on each as it arrives if it has sent <samp>SETTINGS_QPACK_BLOCKING_PERMITTED</samp>, but MAY process checkpoint streams one at a time.</p>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#insert" id="insert">INSERT</a>
</h1>
<p id="rfc.section.3.2.1.p.1">An addition to the dynamic table starts with the &#8216;1&#8217; one-bit pattern, followed by the new index of the header represented as an integer with a 7-bit prefix.  The decoder adds the supplied header to the checkpoint currently being processed, which is in the NEW state.</p>
<p id="rfc.section.3.2.1.p.2">If the header field name matches the header field name of an entry stored in the static table or the dynamic table, the header field name can be represented using the index of that entry. In this case, the <samp>S</samp> bit indicates whether the reference is to the static (S=1) or dynamic (S=0) table and the index of the entry is represented as an integer with an 7-bit prefix (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>). This value is always non-zero.</p>
<p id="rfc.section.3.2.1.p.3">If an INSERT instruction uses an existing dynamic table entry for the name of an entry being added to the NEW checkpoint, both the existing entry and the new entry are referenced by the NEW checkpoint.  INSERT instructions which reference the dynamic table MUST reference only entries which are already included in a LIVE checkpoint.  This avoids the possibility of one checkpoint stream blocking on a different checkpoint.</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 |       New Index (7+)      |
   +---+---------------------------+
   | S |       Name Index (7+)     |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
</pre>
<p class="figure">INSERT instruction -- Indexed Name</p>
<p id="rfc.section.3.2.1.p.4">Otherwise, the header field name is represented as a string literal (see Section 5.2 of <a href="#RFC7541" class="xref">[RFC7541]</a>). A value 0 is used in place of the table reference, followed by the header field name.</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 |       New Index (7+)      |
   +---+---------------------------+
   |               0               |
   +---+---------------------------+
   | H |     Name Length (7+)      |
   +---+---------------------------+
   |  Name String (Length octets)  |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
</pre>
<p class="figure">INSERT instruction -- New Name</p>
<p id="rfc.section.3.2.1.p.5">Either form of header field name representation is followed by the header field value represented as a string literal (see Section 5.2 of <a href="#RFC7541" class="xref">[RFC7541]</a>).</p>
<p id="rfc.section.3.2.1.p.6">An encoder MUST NOT attempt to place a value at an index not known to be vacant.  A decoder MUST treat the attempt to insert into an occupied slot or reference a name in a vacant slot as a fatal error.</p>
<h1 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#touch" id="touch">TOUCH</a>
</h1>
<p id="rfc.section.3.2.2.p.1">This instruction is emitted to link a NEW checkpoint to an existing header table entry created by a previous checkpoint. This causes the entry not to be removed from the table so long as the current checkpoint is alive.</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 |         Index (7+)        |
+---+---------------------------+
</pre>
<p class="figure">Indexed Header Field</p>
<p id="rfc.section.3.2.2.p.2">The encoder SHOULD NOT issue multiple TOUCH commands for the same entry in the context of the same NEW checkpoint.  If a non-existent index is specified, the decoder MUST treat is as an error.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#request-streams" id="request-streams">Request Streams</a>
</h1>
<p id="rfc.section.3.3.p.1">Frames which carry HTTP message headers begin with an optional preface indicating potentially-blocking references in the frame. If present, this preface indicates that the request depends on one or more checkpoints which were NEW or PENDING for the encoder when the frame was generated.  If these checkpoints are not LIVE on the decoder, it MAY delay reading the remainder of the frame until they are.  (If any of these checkpoints have already been dropped, this must be treated as a stream error of type ERROR_QPACK_INVALID_REFERENCE.)</p>
<p id="rfc.section.3.3.p.2">The preface is formatted as follows:</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | L |      Checkpoint (7+)      |
   +---+---+---+-------------------+
   | L |      Checkpoint (7+)      |
   +---+---------------------------+
   |              ...              |
   +-------------------------------+
</pre>
<p class="figure">QPACK preface</p>
<p id="rfc.section.3.3.p.3">The <samp>L</samp> bit indicates that this checkpoint is the last checkpoint in the preface; if the bit is unset (0), then another checkpoint follows.</p>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#indexed-header-field-representation" id="indexed-header-field-representation">Indexed Header Field Representation</a>
</h1>
<p id="rfc.section.3.3.1.p.1">An indexed header field representation identifies an entry in either the static table or the dynamic table and causes that header field to be added to the decoded header list, as described in Section 3.2 of <a href="#RFC7541" class="xref">[RFC7541]</a>.</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 | S |      Index (6+)       |
+---+---+-----------------------+
</pre>
<p class="figure">Indexed Header Field</p>
<p id="rfc.section.3.3.1.p.2">An indexed header field starts with the &#8216;1&#8217; 1-bit pattern, followed by the <samp>S</samp> bit indicating whether the reference is into the static (S=1) or dynamic (S=0) table. Finally, the index of the matching header field is represented as an integer with a 6-bit prefix (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>).</p>
<p id="rfc.section.3.3.1.p.3">The index value of 0 is not used.  It MUST be treated as a decoding error if found in an indexed header field representation.</p>
<h1 id="rfc.section.3.3.2">
<a href="#rfc.section.3.3.2">3.3.2.</a> <a href="#literal-header-field-representation" id="literal-header-field-representation">Literal Header Field Representation</a>
</h1>
<p id="rfc.section.3.3.2.p.1">A literal header field representation starts with the &#8216;0&#8217; 1-bit pattern and causes a header field to be added the decoded header list.</p>
<p id="rfc.section.3.3.2.p.2">The second bit, &#8216;N&#8217;, indicates whether an intermediary is permitted to add this header to the dynamic header table on subsequent hops. When the &#8216;N&#8217; bit is set, the encoded header MUST always be encoded with this specific literal representation. In particular, when a peer sends a header field that it received represented as a literal header field with the &#8216;N&#8217; bit set, it MUST use the same representation to forward this header field.  This bit is intended for protecting header field values that are not to be put at risk by compressing them (see Section 7.1 of <a href="#RFC7541" class="xref">[RFC7541]</a> for more details).</p>
<p id="rfc.section.3.3.2.p.3">If the header field name matches the header field name of an entry stored in the static table or the dynamic table, the header field name can be represented using the index of that entry. In this case, the <samp>S</samp> bit indicates whether the reference is to the static (S=1) or dynamic (S=0) table and the index of the entry is represented as an integer with an 5-bit prefix (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>). This value is always non-zero.</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | N | S |  Name Index (5+)  |
   +---+---+---+-------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
</pre>
<p class="figure">Literal Header Field -- Indexed Name</p>
<p id="rfc.section.3.3.2.p.4">Otherwise, the header field name is represented as a string literal (see Section 5.2 of <a href="#RFC7541" class="xref">[RFC7541]</a>). A value 0 is used in place of the 6-bit index, followed by the header field name.</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | N |           0           |
   +---+---+-----------------------+
   | H |     Name Length (7+)      |
   +---+---------------------------+
   |  Name String (Length octets)  |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
</pre>
<p class="figure">Literal Header Field -- Literal Name</p>
<p id="rfc.section.3.3.2.p.5">Either form of header field name representation is followed by the header field value represented as a string literal (see Section 5.2 of <a href="#RFC7541" class="xref">[RFC7541]</a>).</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#use-in-httpquic" id="use-in-httpquic">Use in HTTP/QUIC</a>
</h1>
<p id="rfc.section.4.p.1">HTTP/QUIC <a href="#I-D.ietf-quic-http" class="xref">[I-D.ietf-quic-http]</a> currently retains the HPACK encoder/decoder from HTTP/2, but restricts the size of the dynamic table to zero. Using QPACK instead would entail the following changes:</p>
<p></p>

<ul>
<li>Header Blocks consist of QPACK data instead of HPACK data</li>
<li>HEADERS and PUSH_PROMISE frames define a flag indicating the presence of a preface.</li>
<li>Just as unidirectional push streams have a stream header identifying their Push ID, a header will need to be added to differentiate checkpoint streams from pushes</li>
<li>Stream 2 is reserved for the Feedback Stream</li>
</ul>
<p id="rfc.section.4.p.3">A HEADERS or PUSH_PROMISE frame MAY contain an arbitrary number of QPACK instructions.  A partial HEADERS or PUSH_PROMISE frame MAY be processed upon arrival and the resulting partial header set emitted or buffered according to implementation requirements.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#setting-block" id="setting-block">SETTING_QPACK_BLOCKING_PERMITTED</a>
</h1>
<p id="rfc.section.4.1.p.1">An HTTP/QUIC implementation can trade off the complexity of its QPACK decoder against compression efficiency by permitting the peer&#8217;s compressor to reference unacknowledged entries.  In the case of loss on a checkpoint stream, such references might cause the processing of request streams to block, waiting for the arrival of missing data.</p>
<p id="rfc.section.4.1.p.2">If the decoder permits the encoder to make blocking references, it sets <samp>SETTING_QPACK_BLOCKING_PERMITTED</samp> (0xSETTING-TBD1) to a non-zero value. The encoder receiving this setting MAY encode up to this number of potentially-blocking references at a time.</p>
<p id="rfc.section.4.1.p.3">Sending this setting with no value indicates that a decoder is willing to tolerate blocking references bounded only by the allowed number of streams. If a decoder does not send this setting or sends this setting with a value of zero, the encoder MUST NOT encode a header using a reference that might block.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#setting-initial" id="setting-initial">SETTING_QPACK_INITIAL_CHECKPOINT</a>
</h1>
<p id="rfc.section.4.2.p.1">An HTTP/QUIC implementation MAY include the <samp>SETTING_QPACK_INITIAL_CHECKPOINT</samp> (0xSETTING_TBD2) setting, containing the full serialization of an initial checkpoint stream&#8217;s data.  If present, this setting MUST be fully processed by the peer before decoding any checkpoint streams or header frames on request streams.</p>
<p id="rfc.section.4.2.p.2">The checkpoint defined by this setting is considered LIVE by both the encoder and the decoder from the beginning of the connection.  The decoder does not need to send an ACK_FLUSH message confirming receipt of this setting.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#implementation-trade-offs" id="implementation-trade-offs">Implementation trade-offs</a>
</h1>
<p id="rfc.section.5.p.1">This document specifies a means for the encoder to express the choices it made while encoding, but intentionally does not mandate what those choices should be.  In this section, potential areas for implementation tuning are explored.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#compression-efficiency-versus-blocking-avoidance" id="compression-efficiency-versus-blocking-avoidance">Compression Efficiency versus Blocking Avoidance</a>
</h1>
<p id="rfc.section.5.1.p.1">If blocking references are permitted, they will block if the frame containing the entry definition is lost or delayed. Encoders MAY choose to trade off compression efficiency and avoid blocking by using literal instructions rather than referencing the dynamic table until the insertion is believed to be complete.</p>
<p id="rfc.section.5.1.p.2">The most efficient compression algorithm will reference a table entry whenever it exists in the table, but risks blocking when subject to packet loss or reordering.  The most conservative algorithm will always emit literals to guarantee that no blocking will ever occur.  Most implementations will choose a balance between these two extremes.</p>
<p id="rfc.section.5.1.p.3">Better efficiency while being similarly conservative can be achieved by permitting references to table entries only once these entries are confirmed to be present in the table.  More optimization can be achieved when the reference is known to be in the same packet as the definition.</p>
<p id="rfc.section.5.1.p.4">Increases in efficiency can be achieved by assuming greater risk of blocking &#8211; implementations might choose a particular balance, or adjust their aggressiveness based on observed network characteristics.</p>
<p id="rfc.section.5.1.p.5">Since it is possible to insert header values without emitting them on a stream, an encoder MAY also proactively insert header values which it believes will be needed on future requests, at the cost of reduced compression efficiency for incorrect predictions.</p>
<p id="rfc.section.5.1.p.6">The ability to split updates to the header table into discrete checkpoints reduces the possibility for head-of-line blocking within the checkpoint streams.  Implementations SHOULD limit the size of checkpoints to avoid head-of-line blocking within these messages.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#timely-state-transitions-versus-decoder-complexity" id="timely-state-transitions-versus-decoder-complexity">Timely State Transitions versus Decoder Complexity</a>
</h1>
<p id="rfc.section.5.2.p.1">Anything which prevent checkpoints from transitioning from DYING to DEAD can prevent the encoder from adding any new entries due to the maximum table size.  This does not block the encoder from continuing to make requests, but could sharply limit compression performance. Encoders would be well-served to begin moving checkpoint to DYING in advance of encountering the table maximum.  Decoders SHOULD be prompt about emitting STREAM_DONE and ACK_DROP instructions to enable the encoder to recover the table space.</p>
<p id="rfc.section.5.2.p.2">Similarly, for decoders which prohibit blocking references, delaying the transition of a checkpoint from PENDING to LIVE will degrade compression performance.  Decoders SHOULD consume checkpoint data and emit ACK_FLUSH frames as promptly as possible.</p>
<p id="rfc.section.5.2.p.3">Since decoders cannot safely drop old checkpoints until they have fully processed any checkpoints which might have been open concurrently, a long-lived checkpoint can delay the completion of an ACK_DROP.  Encoders SHOULD flush all NEW checkpoints as soon as feasible after issuing a DROP instruction.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">A malicious encoder might attempt to consume a large amount of space on the decoder, but as each decoder chooses how much memory to allow the peer to consume, this state is bounded.</p>
<p id="rfc.section.6.p.2">A malicious encoder might also send blocking references to entries which will never actually be defined.  This attack is comparable to a &#8220;slow loris&#8221; attack in which a request is delivered very slowly in an attempt to consume resources on the server.  Similar mitigations (request timers, etc.) SHOULD be employed to guard against such attacks.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.7.p.1">This document registers two settings and one error code with the corresponding HTTP/QUIC registries.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#settings" id="settings">Settings</a>
</h1>
<p id="rfc.section.7.1.p.1">This document registers two entries in the &#8220;HTTP/QUIC Settings&#8221; registry established by <a href="#I-D.ietf-quic-http" class="xref">[I-D.ietf-quic-http]</a>.</p>
<p></p>

<dl>
<dt>Setting Name:</dt>
<dd style="margin-left: 8">SETTING_QPACK_BLOCKING_PERMITTED</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">0xSETTING-TBD1</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8"><a href="#setting-block" class="xref">Section 4.1</a></dd>
</dl>
<p id="rfc.section.7.1.p.3">and</p>
<p></p>

<dl>
<dt>Setting Name:</dt>
<dd style="margin-left: 8">SETTING_QPACK_INITIAL_CHECKPOINT</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">0xSETTING-TBD2</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8"><a href="#setting-initial" class="xref">Section 4.2</a></dd>
</dl>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#errors" id="errors">Errors</a>
</h1>
<p id="rfc.section.7.2.p.1">This document registers one error code in the &#8220;HTTP/QUIC Error Code&#8221; registry established by <a href="#I-D.ietf-quic-http" class="xref">[I-D.ietf-quic-http]</a>.</p>
<p></p>

<dl>
<dt>Error name:</dt>
<dd style="margin-left: 8">ERROR_QPACK_INVALID_REFERENCE</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">0xERROR-TBD</dd>
<dt>Description:</dt>
<dd style="margin-left: 8">A blocking reference was received by a decoder which did not permit it</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8"><a href="#permitted-references" class="xref">Section 2.2.1</a></dd>
</dl>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#ack" id="ack">Acknowledgements</a>
</h1>
<p id="rfc.section.8.p.1">This draft draws heavily on the text of <a href="#RFC7541" class="xref">[RFC7541]</a>, and adopts (with adaptation) the checkpoint model from <a href="#QMIN" class="xref">[QMIN]</a>. The direct and indirect input of those authors is gratefully acknowledged, as well as ideas gleefully stolen from:</p>
<p></p>

<ul>
<li>Jana Iyengar</li>
<li>Patrick McManus</li>
<li>Martin Thomson</li>
<li>Charles &#8216;Buck&#8217; Krasic</li>
<li>Kyle Rose</li>
<li>Alan Frindell</li>
</ul>
<p id="rfc.section.8.p.3">A substantial portion of Mike&#8217;s work on this draft was supported by Microsoft during his employment there.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">9.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-quic-http">[I-D.ietf-quic-http]</b></td>
<td class="top">
<a>Bishop, M.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-http-07">Hypertext Transfer Protocol (HTTP) over QUIC</a>", Internet-Draft draft-ietf-quic-http-07, October 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-quic-transport">[I-D.ietf-quic-transport]</b></td>
<td class="top">
<a>Iyengar, J.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-07">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport-07, October 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7540">[RFC7540]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7541">[RFC7541]</b></td>
<td class="top">
<a>Peon, R.</a> and <a>H. Ruellan</a>, "<a href="https://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>", RFC 7541, DOI 10.17487/RFC7541, May 2015.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">9.2.</a> Informative References</h1>
<table><tbody><tr>
<td class="reference"><b id="QMIN">[QMIN]</b></td>
<td class="top">
<a>Tikhonov, D.</a>, "<a href="https://tools.ietf.org/html/draft-tikhonov-quic-qmin-00">QMIN: Header Compression for QUIC</a>", Internet-Draft draft-tikhonov-quic-qmin-00, November 2017.</td>
</tr></tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> 
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline">Akamai</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mbishop@evequefou.be">mbishop@evequefou.be</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/MikeBishop/http-misc-extensions">Fork me on GitHub</a></div></div>
</body>
</html>
